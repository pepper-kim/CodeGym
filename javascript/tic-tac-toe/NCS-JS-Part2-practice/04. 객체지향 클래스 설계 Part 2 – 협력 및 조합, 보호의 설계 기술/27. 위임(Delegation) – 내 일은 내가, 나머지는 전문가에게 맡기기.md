# 📘 강의 요약

## \[객체지향] 27. 위임(Delegation) – 내 일은 내가, 나머지는 전문가에게 맡기기

👨‍🍳 모든 일을 혼자 다 하지 않아도 됩니다.
필요한 일은 **전문가 객체에게 맡기고**, 나는 내 역할에만 집중하는 구조!
바로 `위임(Delegation)`을 통해 객체 간 협력 구조를 설계해봅니다.

---

## 🧠 이번 시간에는 – 역할을 나누는 법: 위임(Delegation)

지난 시간엔 mixin을 활용한 `조합(Composition)`을 통해
기능 단위로 객체를 구성하는 방법을 배웠습니다.

모든 기능을 객체 내부에 넣고 직접 처리하는 구조였죠.

하지만 현실의 주방을 떠올려볼까요?

모든 요리를 혼자 다 하는 ‘만능 셰프’는 흔치 않습니다.
메인 요리는 직접 만들되, **디저트는 제과 셰프에게 맡기는 것이 자연스럽죠.**

> 이렇게 어떤 기능을 **다른 객체에게 요청해서 처리**하는 방식,
> 바로 위임(Delegation)입니다.

---

## 🍱 비유 – 셰프와 제과사, 역할 분담의 아름다움

전문 레스토랑에는 다음과 같은 구조가 존재합니다:

* 👨‍🍳 메인 셰프 → 파스타, 스테이크 등 직접 조리
* 🧁 제과 셰프 → 디저트 전문

메인 셰프는 디저트를 굳이 배워서 만들지 않습니다.
그 대신 **“이 케이크 좀 부탁해요”** 하고 제과 셰프에게 요청하죠.

프로그래밍에서도 마찬가지입니다.

모든 기능을 한 객체에 몰아넣는 대신,
**특정 기능은 그 역할에 적합한 객체에게 넘겨주는 설계**가 더 유지보수하기 쉽고 유연합니다.

---

## 🧩 조합과 위임의 차이 – 같은 듯 다르다!

| 구분    | 조합 (Composition)            | 위임 (Delegation)         |
| ----- | --------------------------- | ----------------------- |
| 기능 위치 | 내 객체 안에 직접 기능을 포함           | 기능은 다른 객체에 있고, 나는 호출만 함 |
| 실행 주체 | 내가 직접 기능 수행                 | 다른 객체가 기능을 수행           |
| 비유    | “내가 할게!”                    | “전문가에게 부탁할게”            |
| 코드 방식 | `Object.assign()` 등으로 직접 복사 | 다른 객체를 참조하고 메서드 호출로 위임  |
| 장점    | 코드 재사용, 유연성                 | 역할 분리, 협력 구조 강화         |

---

## ✅ 위임 구조 구현 – 파스타는 내가, 케이크는 제과사에게

### 1️⃣ 제과 셰프 객체 만들기

```js
const pastryChef = {
  makeCake() {
    console.log("제과 셰프: 바닐라 시트에 마스카포네 크림을 올려 케이크를 완성합니다.");
  }
};
```

* `makeCake()`만 정의된 독립적 전문가 객체입니다.
* 다른 객체의 속성이나 구조와 전혀 얽히지 않습니다.

---

### 2️⃣ 메인 셰프 객체에서 위임 구조 정의

```js
function createDelegatingChef(owner, cakeDelegate) {
  return {
    owner,
    makePasta() {
      console.log(`${this.owner}의 파스타: 신선한 생면과 크림 소스로 완성합니다.`);
    },
    makeCake() {
      // 직접 만들지 않고, 다른 객체에 부탁!
      return cakeDelegate.makeCake();
    }
  };
}
```

* `owner`: 셰프 이름
* `cakeDelegate`: 케이크를 위임할 제과 셰프
* 핵심 포인트는 `makeCake()` 내부:
  👉 실행 주체는 `cakeDelegate`입니다!

---

### 3️⃣ 실행 예제

```js
const chef = createDelegatingChef("유진", pastryChef);

chef.makePasta();  // 직접 수행
chef.makeCake();   // 위임해서 수행
```

---

### 🧪 출력 결과

```js
유진의 파스타: 신선한 생면과 크림 소스로 완성합니다.
제과 셰프: 바닐라 시트에 마스카포네 크림을 올려 케이크를 완성합니다.
```

* `makePasta()`는 `chef` 객체 안에서 직접 수행
* `makeCake()`는 외부의 `pastryChef`가 대신 실행

---

## 🔍 시각화 – 위임 구조 흐름

```js
[chef 객체]
├── owner: "유진"
├── makePasta()        ← 직접 구현 및 실행
└── makeCake()         → [pastryChef 객체]에게 위임

[pastryChef 객체]
└── makeCake()         ← 실행 주체
```

💡 `makeCake()` 메서드는 `chef` 내부에 있지만,
진짜 로직은 외부 객체가 처리합니다.

---

## 🧠 왜 위임이 필요할까?

조합만으로도 설계를 잘할 수 있을 것처럼 보일 수 있습니다.
하지만 현실은 언제나 **복잡하고 바빠집니다.**

* 케이크 하나를 만들어도: 반죽, 굽기, 데코레이션, 온도 조절…
  👉 셰프 객체에 다 넣으면 **복잡도 폭발**

* 테스트도 어려워지고, 하나의 기능이 깨지면 전체가 흔들립니다.

### ✅ 위임의 장점

* **책임 분리**: 셰프는 메인 요리만! 제과는 제과 셰프에게!
* **유지보수 용이**: 각 기능을 독립적으로 테스트, 수정 가능
* **현실 반영**: 진짜 팀워크를 코드로 구현

---

## 🧠 실무 예시 – 웹 버튼도 위임한다

예를 들어 "알림장 보내기" 버튼을 누르면…

* 버튼 객체는 메시지를 **직접 전송하지 않습니다.**
* 대신 `NotificationSender` 객체에게 위임합니다:

```js
button.onClick = function () {
  notificationSender.send("오늘 과제 있습니다!");
};
```

👉 이렇게 **UI → 비즈니스 로직 객체로 위임**하는 구조는
실제 프론트엔드 개발에서도 매우 일반적입니다.

---

## 📌 핵심 요약

| 핵심 개념      | 설명                      |
| ---------- | ----------------------- |
| Delegation | 기능을 다른 객체에 맡기는 협력 구조    |
| 내가 직접 안 함  | 내 객체에 기능이 없어도 실행 가능     |
| 실행 주체      | 호출은 내가, 실행은 다른 객체       |
| 유지보수성      | 기능 분리로 유연하고 안정적인 코드     |
| 실무 적용      | UI, 서비스 로직 분리 등에서 매우 흔함 |

---

## 🚀 다음 강의 예고 – 조합 + 위임, 실전형 설계

다음 시간에는
**조합(Composition)과 위임(Delegation)을 함께 사용하는 복합 구조**를 배워봅니다!

* 파스타: 직접 만든다 (내 기능)
* 샐러드: mixin으로 조합한다
* 케이크: 제과 셰프에게 위임한다

이런 식으로 다양한 방식이 하나의 객체 안에서 공존하는
**현실적인 객체 설계의 완성판**을 함께 만들어봅시다!

그럼 다음 수업에서 뵙겠습니다. 🍝🍰✨

---
