# 📘 강의 요약

## \[객체지향] 26. 조합(Composition) – 상속 없이 객체를 부품처럼 조립하는 유연한 설계

🔩 여러 기능을 객체에 **직접 결합해서 조립하는 방식**, 조합(Composition)으로 확장성과 유연성을 확보하자!

---

## 🧠 이번 시간에는 – 상속을 넘어서: 조합(Composition)이라는 새로운 방식

우리는 지금까지 객체지향 설계에서 **상속**을 중심으로 배워왔습니다.

부모 클래스가 있고, 자식 클래스가 그 기능을 물려받아 사용하거나 재정의하는 구조였죠.
`extends`, `super()`, `override`, `추상 클래스`와 같은 키워드를 이용해 기능을 자연스럽게 계승하고, 필요에 따라 자신의 방식으로 바꾸는 경험을 해보았습니다.

하지만 여기서 생각해볼 문제가 있습니다.

> 꼭 하나의 클래스에서만 기능을 물려받아야 할까요?
> 서로 다른 역할들을 객체에 **유연하게 조립**하고 싶을 땐 어떻게 할까요?

이 질문에 답을 주는 것이 바로 오늘의 주제인 `조합(Composition)`입니다.

---

## 🍱 비유: 상속은 한 권의 레시피북, 조합은 여러 권에서 필요한 것만 골라 쓰는 방식

**상속**은 마치 엄마의 전통 레시피북을 딸이 그대로 물려받아 쓰는 방식입니다.
그런데 실제 요리사들은 한 권만 보지 않죠!

예를 들어 퓨전 된장찌개를 만든다고 할 때:

* 육수는 일본 요리책에서,
* 양념은 프랑스 요리책에서,
* 기본 국물은 전통 한식 레시피에서 따올 수 있습니다.

이처럼 `필요한 기능만 골라 조립하는 방식이 조합(Composition)`입니다.
이는 구조 전체를 계승하는 상속과 달리, 필요한 기능만 선택적으로 갖다 쓰는 점에서 매우 유연한 방식입니다.

---

## 🧩 조합은 언제 유용할까?

현실의 사람들은 한 가지 역할만 하지 않습니다.
한 사람은 동시에 자녀이기도 하고, 회사에서는 직원이며, 친구들 사이에서는 리더일 수도 있죠.

프로그래밍 객체도 마찬가지입니다.

하나의 객체가 ‘된장찌개 만들기’, ‘육수 내기’, ‘샐러드 만들기’, ‘플레이팅’ 등 여러 기능을 갖는다면,
**상속으로 모두 구현하면 매우 복잡해지고 융통성이 떨어집니다.**

이때 각각의 기능을 작게 나누고,
필요한 것만 골라서 조합하면 **간단하고 유연한 구조**가 됩니다.

이것이 조합(Composition)의 핵심 설계 철학입니다.

---

## 💡 mixin이란?

조합에서 중요한 개념이 바로 mixin(믹스인)입니다.

> mixin은 독립적인 기능 덩어리 객체를 다른 객체에 "섞어 넣는" 방식입니다.
> 전체 클래스를 상속하는 대신, 기능만 쏙쏙 뽑아 조립할 수 있습니다.

기술적으로 mixin은 `Object.assign()`과 같은 도구를 통해 **대상 객체에 기능을 복사해 넣는 방식**입니다.
이때 중요한 점은, 이 기능이 **공유가 아닌 복사**라는 점입니다. 즉, prototype 기반처럼 메서드를 참조하는 것이 아니라, 각 객체 안에 **별도로 저장되는 메서드**입니다.

이로 인해 많은 mixin을 사용할 경우, 메모리 측면에서 비효율적일 수 있으며,
**동일한 이름의 메서드가 여러 mixin에 존재할 경우, 나중에 복사된 것이 앞의 것을 덮어씁니다.**

따라서 실무에서는 mixin 이름 충돌을 막기 위해 **네이밍 규칙을 통일하거나**,
**중첩된 객체 구조**를 사용하여 기능을 명확하게 분리하는 전략이 필요합니다.

---

## ✅ 조합 방식의 코드 예제

### 1️⃣ 각 기능을 mixin 객체로 분리

```js
const StewMaker = {
  makeStew() {
    console.log(`${this.owner}의 된장찌개: 표고버섯 육수와 트러플 오일로 깊은 맛을 냅니다.`);
  }
};

const BrothMaker = {
  makeBroth() {
    console.log("표고버섯, 다시마, 무로 육수를 우려냅니다.");
  }
};
```

🟡 설명:

* `StewMaker`는 된장찌개를 끓이는 기능만 담당하는 객체입니다.
  메서드 `makeStew()`는 이 기능을 실행할 수 있도록 정의되어 있습니다.
* `BrothMaker`는 육수를 만드는 기능만 담당합니다.
  `makeBroth()` 메서드는 육수를 우려내는 과정을 출력합니다.
* 이 두 객체는 클래스로부터 상속받은 것이 아니라, **독립된 순수 기능 단위**로 존재합니다.

---

### 2️⃣ 기능을 합쳐 FusionChef 만들기

```js
function createFusionChef(owner) {
  const chef = { owner }; // 기본 속성만 갖는 빈 객체 생성
  return Object.assign(chef, StewMaker, BrothMaker); // 기능을 결합
}

const fusionChef = createFusionChef("딸");

fusionChef.makeStew();  // 딸의 된장찌개 기능 실행
fusionChef.makeBroth(); // 육수 내기 기능 실행
```

🟡 설명:

* `createFusionChef` 함수는 `owner`라는 이름 정보를 받아 새 객체를 생성합니다.
* `Object.assign()`을 통해 `StewMaker`와 `BrothMaker`의 기능을 이 객체에 덧붙입니다.
* 이 과정에서 각 기능은 복사되어 `fusionChef`에 직접 들어갑니다. (prototype 공유 아님)

---

### 🧪 출력 결과

```js
딸의 된장찌개: 표고버섯 육수와 트러플 오일로 깊은 맛을 냅니다.
표고버섯, 다시마, 무로 육수를 우려냅니다.
```

---

### 🧱 구조 시각화

```js
[fusionChef 객체]
├── owner: "딸"
├── makeStew()    ← StewMaker에서 mixin
└── makeBroth()   ← BrothMaker에서 mixin
```

---

## 🎨 조합의 진짜 힘 – 다양한 기능을 조립해서 마스터 셰프 만들기

이제 mixin을 더 추가해봅시다!

```js
const SaladMaker = {
  makeSalad() {
    console.log("신선한 채소와 발사믹 드레싱으로 샐러드를 만듭니다.");
  }
};

const PlatingArtist = {
  decorateDish() {
    console.log("꽃잎과 소스를 곁들여 아름답게 플레이팅합니다.");
  }
};
```

🟡 설명:

* `SaladMaker`는 샐러드를 만드는 기능을 담고 있고,
* `PlatingArtist`는 플레이팅(요리 장식)을 담당합니다.
* 이들도 독립적인 기능 단위로, 원하는 객체에 쉽게 조합될 수 있습니다.

---

### 🔧 조합으로 마스터 셰프 만들기

```js
function createMasterChef(owner) {
  const chef = { owner };
  return Object.assign(
    chef,
    StewMaker,
    BrothMaker,
    SaladMaker,
    PlatingArtist
  );
}

const masterChef = createMasterChef("셰프 루이");

masterChef.makeBroth();       // 육수 만들기
masterChef.makeStew();        // 된장찌개 만들기
masterChef.makeSalad();       // 샐러드 만들기
masterChef.decorateDish();    // 플레이팅
```

🟡 설명:

* `createMasterChef` 함수는 다양한 기능을 조합하여 마스터 셰프 객체를 만듭니다.
* `Object.assign()`으로 여러 mixin을 결합하면, 각 기능이 `masterChef` 객체의 **직접 속성**이 됩니다.
* 이 방식은 **상속 없이도** 복잡한 기능을 가진 객체를 만들 수 있게 해줍니다.

---

### 🧪 출력 결과

```js
표고버섯, 다시마, 무로 육수를 우려냅니다.
셰프 루이의 된장찌개: 트러플 오일과 표고버섯 육수로 깊은 맛을 냅니다.
신선한 채소와 발사믹 드레싱으로 샐러드를 만듭니다.
꽃잎과 소스를 곁들여 아름답게 플레이팅합니다.
```

---

### 🧱 구조 시각화

```js
[masterChef 객체]
├── owner: "셰프 루이"
├── makeStew()       ← StewMaker에서 mixin
├── makeBroth()      ← BrothMaker에서 mixin
├── makeSalad()      ← SaladMaker에서 mixin
└── decorateDish()   ← PlatingArtist에서 mixin
```

---

## 📌 핵심 요약

| 항목              | 설명                                                |
| --------------- | ------------------------------------------------- |
| 조합(Composition) | 기능 단위 객체를 조립해 새로운 객체를 구성하는 방식                     |
| mixin           | 독립 기능을 담은 객체, 필요할 때만 조합 가능. 단, 복사되므로 메모리 사용 증가 가능 |
| Object.assign() | 여러 기능 객체를 대상 객체에 얕은 복사로 덧붙이는 핵심 도구                |
| 상속과 차이점         | 상속은 구조 전체를 계승, 조합은 필요한 기능만 선별 적용                  |
| 주의할 점           | 메서드 충돌 가능성 있음. mixin 이름 규칙 및 충돌 방지 설계 필요          |
| 장점              | 유연성, 유지보수성, 재사용성, 확장성 모두 뛰어나며 설계가 간결해짐            |

---

## 🧠 흐름 요약

```js
[기능 객체 준비]
↓
[Object.assign()으로 기능 결합]
↓
[최종 객체 생성]
↓
[조립된 메서드 실행]
```

---

## 🚀 다음 강의 예고: 위임(Delegation)

조합은 객체에 기능을 **직접 추가**하는 방식이었다면,
다음 시간에 배울 위임은 \*\*“필요한 기능을 다른 객체에게 부탁하는 구조”\*\*입니다.

👉 내가 하지 않아도 돼! 필요한 건 다른 전문가에게 맡겨!

위임을 통해, **객체 간의 협력과 책임 분산** 설계를 배워보겠습니다.
그럼 다음 수업에서 뵙겠습니다! 🍛✨

---
