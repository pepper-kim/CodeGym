# 📘 강의 요약

## \[객체지향] 29. 역할과 책임 – 객체 협력의 기준을 세우는 원칙

🎯 객체는 기능이 아닌 **책임 단위로 설계**되어야 한다.
역할을 분리하고, 각자의 일을 충실히 수행하는 협력 구조를 만들어보자!

---

## 🧠 이번 시간에는 – 객체가 ‘해야 할 일’ 중심으로 생각해보기

지난 강의에서 우리는 셰프 객체가

* `makeStew()`는 직접 수행하고 (조합)
* `makeBroth()`, `makeSalad()`는 전문가에게 맡겼던 (위임) 구조를 살펴봤습니다.

이제 더 중요한 질문을 던져야 할 시간입니다:

> “이 객체는 정확히 어떤 역할을 맡아야 하지?”
> “이 기능이 바뀔 때, 누가 책임져야 하지?”

이것이 바로 객체지향 설계의 핵심 원칙 중 하나:
**Single Responsibility Principle (단일 책임 원칙)**
한 객체는 **하나의 역할**, **하나의 책임**만 가져야 한다는 철학입니다.

---

## 🍽 실생활 비유 – 셰프는 요리만, 배달은 배달원이!

* 셰프: 요리 전담
* 배달원: 배달 전담
* 고객: 먹는 일만

만약 셰프가 요리, 배달, 서빙까지 다 한다면?

→ 일의 효율은 떨어지고
→ 전문성도 사라지며
→ 전체 시스템은 무너지게 됩니다.

객체도 마찬가지입니다.
**각자 할 일을 정확히 알고, 그것만 책임지면 협력도 쉬워지고 유지보수도 쉬워집니다.**

---

## ✅ 예제 코드 – 책임이 섞인 객체 vs 분리된 객체

### ❌ 잘못된 구조 – 모든 책임을 셰프가 진다면?

```js
const chef = {
  makeStew() {
    console.log("찌개를 만듭니다.");
  },
  makeBroth() {
    // 육수 로직도 직접 처리
    console.log("다시마와 버섯으로 육수를 우려냅니다.");
  },
  makeSalad() {
    // 샐러드 로직도 직접 처리
    console.log("채소를 다듬고 드레싱을 섞습니다.");
  }
};
```

이 구조는 처음엔 단순해 보이지만…

* 육수 만드는 방식이 바뀌면?
* 샐러드에 새 스타일이 생기면?

모든 변화가 `chef`에 집중되어
→ **수정이 어렵고**,
→ **객체가 점점 커지며**,
→ **역할이 뒤엉키게 됩니다.**

---

### ✅ 올바른 구조 – 역할에 따라 책임 분리

```js
const BrothExpert = {
  makeBroth() {
    console.log("육수 담당: 다시마와 표고버섯으로 깊은 맛을 냅니다.");
  }
};

const SaladExpert = {
  makeSalad() {
    console.log("샐러드 담당: 지중해 스타일로 드레싱을 조합합니다.");
  }
};

function createChef(owner, delegates) {
  return {
    owner,
    makeStew() {
      console.log(`${this.owner}의 찌개를 끓입니다.`);
    },
    makeBroth() {
      delegates.broth.makeBroth();
    },
    makeSalad() {
      delegates.salad.makeSalad();
    }
  };
}

const chef = createChef("지우", {
  broth: BrothExpert,
  salad: SaladExpert
});

chef.makeStew();
chef.makeBroth();
chef.makeSalad();
```

---

### 🧪 출력 결과

```js
지우의 찌개를 끓입니다.
육수 담당: 다시마와 표고버섯으로 깊은 맛을 냅니다.
샐러드 담당: 지중해 스타일로 드레싱을 조합합니다.
```

---

## 🔍 구조 시각화

```js
[Chef 객체]
├── makeStew()      ← 직접 수행 (조합)
├── makeBroth()     → BrothExpert에게 위임
└── makeSalad()     → SaladExpert에게 위임

[BrothExpert 객체]
└── makeBroth()     ← 자신의 책임만 수행

[SaladExpert 객체]
└── makeSalad()     ← 자신의 책임만 수행
```

---

## 🧠 진짜 객체 협력이란? – 분리된 책임에서 시작된다

진짜 객체 협력은
📦 객체가 자기 책임을 정확히 알고,
📨 필요한 일은 협력자에게 위임할 때 시작됩니다.

* 변경이 일어났을 때, 수정할 곳이 명확함
* 새로운 기능이 생겨도, 추가 위치가 분명함
* 코드가 커져도 유지보수가 쉬움

---

## 🛠 실전 설계 – MVC 구조에서 책임은 이렇게 나뉜다

이러한 철학은 실제 실무에서도 그대로 적용됩니다.
대표적인 예: **MVC 아키텍처 + Service 계층**

### 🍜 예시: 메모 저장 요청 처리 흐름

```js
사용자 → routes → controller → service → model → 저장
                              ↘︎
                                view (응답 전달)
```

### 💼 각 계층의 역할

| 계층         | 역할 설명                      |
| ---------- | -------------------------- |
| routes     | 어떤 요청이 어떤 컨트롤러로 갈지 결정      |
| controller | 사용자 요청 흐름 제어, 직접 로직 없음     |
| service    | 실제 처리 로직 수행 (유효성 검사, 저장 등) |
| model      | 데이터 구조 정의, DB 연결           |
| view       | 사용자에게 결과를 보여줌              |

---

### 📁 MVC + Service 구조 시각화

```js
📦 프로젝트 루트
├── 📁 routes         → 요청 분배자
├── 📁 controllers    → 흐름 제어자
├── 📁 services       → 로직 담당자
├── 📁 models         → 데이터 구조 관리자
└── 📁 views          → 사용자 화면 구성
```

---

## 📌 핵심 요약

| 핵심 원칙                  | 설명                            |
| ---------------------- | ----------------------------- |
| 역할(Role) 분리            | 한 객체는 하나의 역할만                 |
| 책임(Responsibility) 명확화 | 기능이 변경될 때 책임 주체가 분명           |
| 객체 협력 구조               | 각 객체는 자신의 일만 수행, 나머지는 위임      |
| 실무 활용                  | MVC 구조, 모듈화, 확장성 설계에 직접 적용 가능 |

---

## 🚀 다음 강의 예고 – 정보를 감추는 기술, 캡슐화(Encapsulation)

이제 우리는 **누가 어떤 역할을 맡아야 하는지** 알게 되었습니다.
다음 시간엔 이 구조를 **안전하게 보호하는 기술**을 배웁니다.

바로 객체 내부의 정보를 외부로부터 `은닉하는 캡슐화(Encapsulation)`입니다.

“비밀 레시피는 공개하지 말자!”
다음 시간에는 그 레시피를 **보호하고 관리하는 기술**을 함께 익혀보겠습니다. 🧪🔐

---
