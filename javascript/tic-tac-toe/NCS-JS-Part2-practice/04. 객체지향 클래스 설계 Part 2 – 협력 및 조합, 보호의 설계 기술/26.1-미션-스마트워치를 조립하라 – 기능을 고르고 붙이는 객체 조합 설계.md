# 📦 “스마트워치를 조립하라 – 기능을 고르고 붙이는 객체 조합 설계”

---

## 🧭 미션 배경

당신은 이제 막 한 기술 중심 스타트업에 합류한 신입 프론트엔드 개발자입니다.
당신의 팀은 지금까지와는 완전히 다른 구조의 새로운 스마트워치 플랫폼을 만들고 있습니다.

기존의 스마트워치 코드를 한 번 떠올려 볼까요?
하나의 클래스로 모든 기능을 몽땅 다 넣는 구조였기 때문에, 코드가 점점 복잡해지고 무거워지는 문제가 발생했습니다.

예를 들어, 스마트워치에 심박수 측정, 음악 재생, 날씨 확인, 걸음 수 측정 같은 기능이 모두 들어있다고 가정해봅시다.
이 중에서 실제로 어떤 사람은 심박수 기능만 필요하고, 어떤 사람은 날씨만 보고 싶어 하기도 합니다.
그런데도 모든 기능이 기본 탑재되어 있다면, 사용자는 원치 않는 기능도 억지로 들고 다녀야 하며, 개발자는 전체 구조를 변경해야 할 때마다 모든 기능을 수정해야 하죠.

요즘은 다릅니다.
고객은 자신의 라이프스타일에 맞는 기능만 직접 고르고 조합하고 싶어합니다.

> "나는 음악 재생만 되는 가벼운 워치가 좋아."
> "나는 날씨와 심박수만 보면 돼."
> "기능을 내가 직접 붙여서 내 워치를 만들 수 없을까?"

바로 이 흐름에 맞춰, 회사에서는 스마트워치의 기능을 하나하나 독립된 부품처럼 설계하고,
필요한 기능만 조합해서 객체를 만들 수 있는 방식, 즉 **조합(Composition)** 기반의 설계를 도입하고자 합니다.

이때 가장 핵심이 되는 구조는 바로 **mixin**.
mixin은 말 그대로, 기능 하나하나를 부품처럼 따로 만든 모듈입니다.
클래스를 상속하지 않고도, 이 부품들을 조립해서 객체에 붙이면
하나의 완성된 ‘사용자 맞춤형 스마트워치’가 만들어지는 거죠.

---

## 🎯 미션 목표

당신의 임무는 다음과 같습니다:

- 클래스 상속 없이 객체를 구성합니다.
- 각각의 기능을 개별 **mixin**으로 만들고, 사용자가 선택한 기능만 객체에 붙입니다.
- `Object.assign()`을 사용하여 여러 기능을 하나의 객체에 병합합니다.
- 모든 기능은 객체 **메서드**로 동작해야 하며, **사용자 이름을 기준으로 작동 메시지를 출력**해야 합니다.

---

## 📋 미션 요구사항

아래 기능들이 각각 독립된 기능 모듈(mixin)으로 주어집니다:

- `HeartRateMonitor`: 심박수 측정 기능
- `MusicPlayer`: 음악 재생 기능
- `WeatherDisplay`: 날씨 정보 출력 기능

당신은 다음을 구현해야 합니다:

- 각 기능을 별개의 mixin 객체로 만듭니다.
- 사용자 이름을 기반으로 스마트워치를 생성하고,
- 전달받은 기능만 선택적으로 붙여서 완성된 객체를 반환합니다.
- 최종적으로 조립된 객체는 각 기능의 메서드를 호출할 수 있어야 합니다.

---

## 🔤 사용 문법 요약

- `Object.assign(target, ...sources)`
  → 대상 객체에 여러 source 객체(mixin들)를 덧붙입니다.
- `mixin`
  → 기능 단위로 만든 독립 모듈 객체
- 팩토리 함수
  → 함수로 객체를 생성하고 초기화하는 패턴

---

## 📚 이 미션을 통해 배우는 것

- 조합(Composition)이란 무엇인가, 그리고 이것이 상속과 어떤 차이가 있는가
- mixin의 역할과 실무에서의 중요성
- 객체 구조를 더 유연하고 확장 가능하게 만드는 방법
- 실무에서 "불필요한 기능을 제거하고 필요한 것만 포함하는 설계 방식"을 어떻게 구현할 수 있는가

---

## ✨ 예상 출력 예시

```js
홍길동님의 심박수 측정 중... 안정적인 상태입니다.
홍길동님의 현재 지역 날씨: 맑고 기온 23도입니다.

민지님이 좋아하는 음악을 재생합니다: 🎵

동현님의 심박수 측정 중... 안정적인 상태입니다.
동현님이 좋아하는 음악을 재생합니다: 🎵
동현님의 현재 지역 날씨: 맑고 기온 23도입니다.
```

---

## ✅ 정답 코드

```js
// 각 기능을 개별적인 mixin으로 정의
const HeartRateMonitor = {
  checkHeartRate() {
    console.log(`${this.owner}님의 심박수 측정 중... 안정적인 상태입니다.`);
  },
};

const MusicPlayer = {
  playMusic() {
    console.log(`${this.owner}님이 좋아하는 음악을 재생합니다: 🎵`);
  },
};

const WeatherDisplay = {
  showWeather() {
    console.log(`${this.owner}님의 현재 지역 날씨: 맑고 기온 23도입니다.`);
  },
};

// 스마트워치 생성기 (조합 구조)
function createSmartWatch(owner, features) {
  const baseWatch = { owner };
  return Object.assign(baseWatch, ...features);
}

// 조합 사용 예시
const userWatch = createSmartWatch("홍길동", [
  HeartRateMonitor,
  WeatherDisplay,
]);
userWatch.checkHeartRate();
userWatch.showWeather();
```

---

## ✅ 상세 설명

### 🧩 mixin 정의

이 미션에서 가장 중요한 구조는 **mixin**입니다.
mixin은 클래스를 사용하지 않고, 하나의 기능만을 수행하는 **작은 객체**입니다.
각 기능은 단 하나의 책임만 가지고 있어야 하며, 여러 객체에 재사용할 수 있도록 독립적으로 설계됩니다.

```js
const HeartRateMonitor = {
  checkHeartRate() {
    console.log(`${this.owner}님의 심박수 측정 중... 안정적인 상태입니다.`);
  },
};
```

여기서의 핵심 포인트는:

- `HeartRateMonitor`는 **함수나 클래스가 아닌 단순 객체**입니다.
- 내부에서 `this.owner`를 사용하는데, 이것은 나중에 이 기능이 복사되어 붙을 **스마트워치 객체의 owner**를 참조합니다.
- 같은 방식으로 `MusicPlayer`, `WeatherDisplay`도 **기능 하나에만 집중된 독립적인 객체**로 구성됩니다.

---

### 🧩 createSmartWatch 구조

```js
function createSmartWatch(owner, features) {
  const baseWatch = { owner };
  return Object.assign(baseWatch, ...features);
}
```

이 함수는 두 단계로 작동합니다:

1. **기본 객체 생성**

```js
const baseWatch = { owner };
```

사용자 이름만 가진 빈 객체를 만들고,

2. **기능 병합**

```js
return Object.assign(baseWatch, ...features);
```

넘겨받은 mixin 배열을 전개(`...`)해서 하나씩 baseWatch에 병합합니다.
결과적으로, 원하는 기능만 탑재된 **맞춤형 스마트워치 객체**가 완성됩니다.

---

## 🧪 테스트 흐름

```js
const minjiWatch = createSmartWatch("민지", [MusicPlayer]);
minjiWatch.playMusic(); // ✅ 민지님이 좋아하는 음악을 재생합니다

const donghyunWatch = createSmartWatch("동현", [
  HeartRateMonitor,
  MusicPlayer,
  WeatherDisplay,
]);
donghyunWatch.checkHeartRate(); // ✅ 동현님의 심박수 측정 중...
donghyunWatch.playMusic(); // ✅ 동현님이 좋아하는 음악 재생
donghyunWatch.showWeather(); // ✅ 날씨 정보 출력
```

---

## 🧱 구조 시각화

```js
[SmartWatch 객체]
  ├── owner: "홍길동"
  ├── checkHeartRate()   ← HeartRateMonitor에서 복사됨
  └── showWeather()      ← WeatherDisplay에서 복사됨

[각 mixin 기능 모듈]
  ├── HeartRateMonitor → checkHeartRate()만 담당
  ├── MusicPlayer → playMusic()만 담당
  └── WeatherDisplay → showWeather()만 담당
```

---

## 🧠 구조 요약

- \*\*조합(Composition)\*\*은 상속처럼 계층 구조를 만들지 않고, **기능을 수평적으로 선택**해서 객체에 붙이는 설계 방식입니다.
- **mixin**은 기능 하나만 책임지는 **재사용 가능한 모듈 객체**입니다.
- `Object.assign()`을 사용하면 여러 mixin을 하나의 객체에 병합할 수 있습니다.
- 이 구조는 실무에서 **확장성, 유지보수성, 불필요 기능 제거**에 탁월한 효과를 발휘합니다.

---

## 🎓 **OOP적 가치를 어떻게 실무에 연결할 수 있을까요?**

#### ✅ **이번 미션으로 어떤 OOP 철학을 익혔나요?**

1. **유연성 (Flexibility)**

   - 객체를 만들 때 '미리 정해진 틀'인 클래스를 따르지 않고, 사용자의 필요에 맞게 원하는 기능만 골라 붙일 수 있습니다.
   - 실무에서는 요구사항이 자주 변하는데, 이런 설계 덕분에 코드를 뜯어고치지 않고도 새로운 기능을 쉽게 추가하거나 제거할 수 있습니다.

2. **재사용성 (Reusability)**

   - 한 번 만든 mixin은 다양한 객체에서 재사용됩니다.
   - 예를 들어, 심박수 측정 기능은 스마트워치뿐만 아니라 향후 개발할 운동 기기나 건강 관리 앱에도 그대로 사용할 수 있겠죠.

3. **단일 책임 원칙 (SRP)**

   - 각각의 mixin은 하나의 책임만 담당합니다.
   - `HeartRateMonitor`는 오직 심박수 측정만, `MusicPlayer`는 오직 음악 재생만 담당합니다.
   - 이런 구조는 테스트도 쉽고, 오류가 발생해도 해당 기능만 집중적으로 수정하면 되기 때문에 유지보수 비용을 줄일 수 있습니다.

---

#### 📈 **실무에서 어디에 활용될 수 있을까요?**

- ✅ **UI 컴포넌트 설계 (React, Vue 등)**
  → 버튼, 모달, 알림창 같은 컴포넌트에 필요한 기능만 조합해서 가볍고 최적화된 UI를 만들 수 있습니다.

- ✅ **플러그인 기반 시스템 (CMS, 대시보드, SaaS 플랫폼)**
  → 고객마다 원하는 플러그인만 제공하는 유연한 서비스 제공 가능. (예: Shopify, WordPress)

- ✅ **게임 개발 (Unity, Phaser 등)**
  → 캐릭터에 공격, 방어, 회복 같은 기능을 mixin으로 조립해서 다양한 플레이 스타일을 구현할 수 있습니다.

- ✅ **IoT 디바이스 설계**
  → 센서, 디스플레이, 네트워크 기능을 mixin처럼 조립하여 최적의 장치 구성이 가능합니다.

---

#### 💪 **어떤 연습을 더 하면 좋을까요?**

1. **추가적인 기능 구현 연습**

   - 스마트워치에 알람 기능, GPS 트래킹, 캘린더 알림 같은 새로운 mixin을 직접 추가해보세요.

2. **팩토리 함수 확장하기**

   - 현재는 owner만 받고 있지만, 옵션으로 초기 설정 값을 받아서 각 기능에 초기 상태를 부여하도록 확장해보세요.

3. **프로퍼티 충돌 해결 연습**

   - 여러 mixin에서 같은 이름의 메서드나 프로퍼티가 있을 때, 어떻게 충돌을 방지할지 고민해보세요. (예: 네임스페이스 적용, 우선순위 지정)

4. **클래스와 조합 비교 실습**

   - 동일한 기능을 클래스를 이용해 구현하고, 조합 방식과 비교해 어떤 점이 더 유연하고 관리가 쉬운지 스스로 분석해보세요.

---

#### 🎁 **마지막으로, 실무 감각을 높이기 위한 한 가지 팁!**

👉 **"작게 만들고, 필요할 때 조합하라!"**
실무에서는 처음부터 모든 기능을 한 번에 만들려고 하지 마세요.
작은 기능들을 완성도 높게 설계한 후, 조립하듯이 필요한 순간에 붙여 쓰는 습관을 들이세요.
이런 설계 감각이 쌓이면, 어느새 유지보수가 쉬운 고급 시스템을 설계하는 자신을 발견할 수 있을 겁니다.

---

**이제, 여러분의 코드는 더 이상 무겁고 복잡한 괴물이 아니라, 가볍고 세련된 맞춤형 도구가 될 준비를 마쳤습니다. 🚀
계속해서 유연한 사고와 설계력을 키워가세요! 🙌**
