# 📘 강의 요약

## \[객체지향] 21. 클래스 상속의 시작 – `extends`로 부모 클래스 기능 물려받기

---

## 🧠 왜 상속을 배우는가?

앞선 강의에서는 `class` 문법으로 객체를 설계하고,
속성은 각 객체에 저장하고,
공통 메서드는 자동으로 `prototype`에 등록되어
**메모리 절약과 유지보수 효율**을 동시에 누릴 수 있다는 점을 배웠습니다.

그런데 실제 개발 현장에서는

> “이미 만들어둔 클래스가 있는데, 기능 대부분은 그대로 두고 몇 가지만 고쳐서 새로운 클래스를 만들고 싶어요.”

라는 상황이 정말 자주 발생합니다.

예를 들어 `User`라는 클래스가 있는데,
여기에 `AdminUser`를 만들고자 할 때
기존 기능을 전부 복사해서 다시 쓰는 건 **중복 코드 지옥**이죠.

이럴 때 바로 등장하는 개념이 **상속(Inheritance)** 입니다.

> ✅ 기존 기능을 그대로 물려받고
> ✅ 필요한 부분만 재정의하거나 추가하여
> ✅ 코드 중복 없이 새로운 객체 구조를 만들 수 있는 방법

---

## 🧩 상속이란 무엇인가? – 구조와 역할

상속은 객체지향 프로그래밍의 핵심 개념입니다.

기존 클래스를 **부모 클래스(또는 상위 클래스)** 라고 하고,
이 클래스를 확장해서 만든 새로운 클래스를
**자식 클래스(또는 하위 클래스)** 라고 부릅니다.

자식 클래스는

* 부모의 기능을 그대로 사용할 수 있고
* 필요한 경우 부모의 기능을 자신만의 방식으로 **재정의(override)** 할 수 있으며
* 새로운 기능을 **추가**할 수도 있습니다.

즉, **기존 것을 기반으로 확장하며 발전시키는 방식**입니다.

---

## 🎬 비유 – 부모님의 전통 레시피북 → 자식의 퓨전 레시피북

비유로 설명해봅시다.

👵 부모님은 전통 레시피북을 만들어두셨습니다.
→ 된장찌개, 김치찌개, 계란말이 같은 기본 요리법이 담겨 있습니다.

👩 자식은 이 레시피북을 물려받습니다.
→ 기본 요리는 그대로 따라할 수 있고,
→ 자신만의 요리를 추가하거나,
→ 기존 레시피에 트러플 오일 같은 특별한 재료를 넣어 퓨전 요리로 만들 수도 있죠.

이처럼

> **기존의 것을 그대로 사용할 수도 있고, 필요할 때는 바꿔서 쓸 수도 있는 구조**

이게 바로 상속입니다.
그리고 자바스크립트의 `class` 문법에서는
`extends` 와 `super()`를 통해 이런 구조를 구현할 수 있습니다.

---

## 🧱 클래스 상속 구조를 먼저 시각화로 이해해보기

```js
[RecipeBook 클래스] ← 부모 클래스
   └── makeStew()   ← 전통 된장찌개 레시피

      ⬇️ extends

[FusionRecipeBook 클래스] ← 자식 클래스
   ├── makeStew() (override)       ← 전통 레시피를 나만의 방식으로 재정의
   └── makeSignatureDish()         ← 완전히 새로운 시그니처 요리 추가
```

> 자식 클래스는
> ✅ 부모의 기능을 기본으로 사용하고,
> ✅ 필요할 때 오버라이드하거나 기능을 추가할 수 있음

이 시점에서 핵심은 다음 두 가지입니다:

1. 자식 클래스는 부모 클래스의 모든 메서드를 **자동으로 물려받는다.**
2. 자식 클래스는 원하면 **부모의 기능을 덮어쓰거나**, 새로운 기능을 추가할 수 있다.

---

## 🔑 extends – 부모 클래스를 상속받는 첫걸음

이러한 상속 관계를 자바스크립트에서 구현할 때 사용하는 키워드가
바로 `extends`입니다.

* 영어 뜻: “확장하다”
* 자바스크립트에서의 의미:

  > 자식 클래스가 부모 클래스의 기능을 그대로 물려받고 확장한다는 뜻

```js
class Dog extends Animal {}
```

위처럼 작성하면,
`Dog`는 `Animal` 클래스의 모든 기능을 자동으로 사용할 수 있게 됩니다.

---

## ✅ 코드로 직접 확인해보기

### 1️⃣ 부모 클래스 정의

```js
class Animal {
  sound() {
    console.log("동물이 소리를 냅니다!");
  }
}
```

🔍 줄별 상세 해설:

* `class Animal { ... }` : `Animal`이라는 이름의 클래스(객체 설계도)를 정의합니다.
* `sound()` : 이 클래스에서 모든 동물이 가질 수 있는 공통 메서드입니다.

  * 출력 메시지는 `"동물이 소리를 냅니다!"`로 고정되어 있습니다.

---

### 2️⃣ 자식 클래스 정의 – extends로 상속

```js
class Dog extends Animal {
  // Animal 클래스의 모든 기능을 자동으로 물려받습니다.
}
```

🔍 줄별 상세 해설:

* `class Dog extends Animal` : `Dog`라는 새로운 클래스를 만들면서, `Animal`의 기능을 상속합니다.
* 이 시점에서 `Dog` 클래스에는 아무 기능이 없어도,

  * `sound()` 같은 부모의 메서드는 그대로 사용할 수 있게 됩니다.

---

### 3️⃣ 객체 생성 후 메서드 사용

```js
const max = new Dog();
max.sound(); // 출력: 동물이 소리를 냅니다!
```

🔍 줄별 상세 해설:

* `new Dog()` : `Dog` 클래스를 기반으로 새로운 객체 `max`를 생성합니다.
* `max.sound()` : `Dog` 클래스에는 `sound()`가 없지만,
  상속받은 `Animal` 클래스의 `sound()`를 찾아서 실행하게 됩니다.

---

## 👀 extends 내부 구조 시각화 및 prototype 체인 흐름

```js
[max 객체]
   └── [[Prototype]] → Dog.prototype
                             └── [[Prototype]] → Animal.prototype
                                                   └── sound()
```

🧠 구조 설명:

* 객체 `max`는 `Dog` 클래스로 만들어졌으므로 → `Dog.prototype`을 참조합니다.
* 하지만 `Dog`는 `Animal`을 상속받았기 때문에,
  `Dog.prototype`의 `[[Prototype]]`은 `Animal.prototype`에 연결됩니다.
* `max.sound()`를 실행하면:

  1. `max` 객체 내부에서 `sound`를 찾고,
  2. 없으면 `[[Prototype]]`인 `Dog.prototype`으로 올라가고,
  3. 그래도 없으면 `Animal.prototype`에서 찾아서 실행합니다.

> ✅ 표준 방식으로 확인하려면 `Object.getPrototypeOf(max)`를 사용합니다.

```js
console.log(Object.getPrototypeOf(max) === Dog.prototype); // true
console.log(Object.getPrototypeOf(Dog.prototype) === Animal.prototype); // true
```

---

## 💡 extends 없이 같은 기능 구현하려면?

자바스크립트의 옛날 방식(ES5)으로는 이렇게 해야 합니다:

```js
function Animal() {}
Animal.prototype.sound = function () {
  console.log("동물이 소리를 냅니다!");
};

function Dog() {}
Dog.prototype = Object.create(Animal.prototype);
Dog.prototype.constructor = Dog;

const max = new Dog();
max.sound(); // 출력: 동물이 소리를 냅니다!
```

🔍 설명:

* `Animal`과 `Dog`는 생성자 함수입니다.
* `Object.create(...)`를 통해 prototype을 수동으로 연결해야 상속이 가능합니다.
* constructor 복원까지 해야 올바른 상속 구조가 완성됩니다.

⚠️ 이 방식은 번거롭고 실수도 잦기 때문에
`class` 문법이 등장하면서 훨씬 깔끔하게 정리된 것입니다.

---

## 📌 핵심 요약

| 개념           | 설명                                               |
| ------------ | ------------------------------------------------ |
| `extends`    | 자식 클래스가 부모 클래스의 기능을 그대로 물려받게 해주는 키워드             |
| 자동 상속        | 자식 클래스는 부모의 메서드를 별도 정의 없이도 사용할 수 있음              |
| prototype 체인 | 자식 → 부모 순으로 기능을 탐색하는 내부 구조 (`[[Prototype]]` 흐름)  |
| 구조 시각화       | max → Dog.prototype → Animal.prototype → sound() |

---

## 🧱 전체 구조 흐름 정리

```js
class Animal {
  sound() { ... }   ← 모든 동물이 공유하는 기능
}

class Dog extends Animal {
  // 아무 것도 없어도 sound() 메서드 자동 상속됨
}

const max = new Dog();
max.sound();  // → Animal의 sound() 실행

┌────────────┐
│   max      │
│────────────│
│ [[Prototype]] ─┼─▶ Dog.prototype
│                │       │
│                └───────┼─▶ Animal.prototype
│                        │      └── sound()
└────────────┘
```

---

## 🚀 다음 강의 예고 – `super()`로 부모의 constructor 이어받기

지금까지는 부모 클래스의 메서드를 상속하는 방법을 배웠습니다.
하지만 객체 생성 시 실행되는 `constructor()`는 조금 다릅니다.

* 부모 클래스의 constructor가 필요한 초기 세팅을 포함하고 있다면?
* 자식 클래스는 그 세팅을 어떻게 이어받아야 할까요?

이때 필요한 것이 바로 `super()`입니다.

> `super`는 부모 클래스의 constructor를 호출하는 특별한 키워드입니다.

다음 강의에서는 `super()`를 통해
자식 클래스가 부모의 초기화 로직을 어떻게 **이어받고 확장할 수 있는지**
자세히 배워보겠습니다.

---

감사합니다. 다음 강의에서 뵙겠습니다! 🙌

---
