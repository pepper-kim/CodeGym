# 📖 실무 설계를 간접 경험하는 시간 OOP로 풀어보는 실무형 이커머스 상품 처리 시스템 – 설계부터 구현까지 완전 정복

---

## 📚 **프로젝트 배경 및 실무 상황 설명**

스타트업 A사는 창립 초기, 하루 수십 건에 불과한 주문과 몇 가지 인기 상품만으로 온라인 쇼핑몰을 운영했습니다. 당시에는 관리 인력이 상품 주문서를 엑셀로 작성하고, 고객 주문이 들어올 때마다 수기로 주문서를 발행한 뒤, 택배사 웹사이트에 직접 송장 정보를 입력하곤 했습니다. 고객 문의가 들어오면, 담당자는 사무실 한 켠에 놓인 메모지와 엑셀 파일을 뒤적이며 "혹시 이 주문 처리됐나요?"라는 질문에 겨우 답변할 수 있는 정도였습니다.

그러나 SNS 마케팅과 구독자 이벤트로 갑작스럽게 트래픽이 폭발하면서, 시스템의 한계는 금세 드러나기 시작했습니다.

- 인기 상품은 이미 품절됐지만 웹사이트에는 여전히 '구매 가능'으로 표시되고,
- 동일한 주문이 중복으로 접수되거나, 아예 주문 내역이 누락되는 일이 빈번하게 발생했습니다.
- 급기야 관리자는 고객이 주문한 제품이 실제로 출고됐는지 확인하려고, 매번 창고에 직접 내려가 재고를 일일이 세어보는 상황까지 벌어졌습니다.

결국, 고객 불만과 CS 문의가 폭발하고, "재고 관리 좀 제대로 하라"는 항의와 함께 환불 요청이 쇄도하는 사태로 이어졌습니다. 이런 혼란 속에서 A사 경영진은 뼈저리게 깨달았습니다.

> "더 이상 수기로 버틸 수 없다. 지금 시스템을 바꾸지 않으면, 성장 기회를 놓칠 뿐 아니라 회사의 신뢰도까지 잃게 된다."

이에 A사 개발팀은 본격적으로 **객체지향 프로그래밍(OOP)** 설계를 도입해, 사람이 수작업으로 처리하던 주문·재고·결제 과정을 자동화하고, 시스템적으로 관리할 수 있는 **내부 백엔드 시스템**을 개발하기로 결정했습니다.

이번 프로젝트는 단순한 코드 작성에 그치지 않습니다.

- **고객**은 웹사이트에서 상품을 쉽고 빠르게 검색하고, 장바구니에 담고, 결제하고, 주문 상태를 실시간으로 확인할 수 있어야 하며,
- **관리자**는 상품 정보를 일괄적으로 등록하고, 재고를 실시간으로 조정하며, 주문 내역과 결제 상태를 명확하게 관리할 수 있어야 합니다.

또한, 빠르게 성장하는 스타트업 특성상, 향후 새로운 결제 수단 추가, 이벤트 시스템, 해외 배송 서비스 같은 확장 요구에 빠르게 대응할 수 있어야 했습니다. 이를 위해 개발팀은 코드를 단순히 '돌아가게' 만드는 것이 아니라, 유지보수성과 확장성을 최우선으로 고려한 **견고하고 유연한 OOP 아키텍처** 설계에 착수했습니다.

# 📈 **비즈니스 요구사항 및 과제 정의 (강화된 버전)**

**🛑 운영 문제 – 실시간 재고/주문 관리 실패로 인한 비즈니스 리스크**

A사의 기존 업무 프로세스는 엑셀, 메모장, 카카오톡 메시지 등 비공식적인 도구에 의존하고 있었습니다. 이로 인해, 재고 상태는 담당자 개인 노트에 적혀 있거나, 구글 드라이브의 오래된 파일에 저장된 경우가 많았습니다.

- 인기 상품이 이미 품절되었음에도 웹사이트에는 여전히 '구매 가능'으로 노출되었고,
- 같은 고객이 중복 주문을 넣고도 취소 요청을 반복하며 CS 팀이 마비되는 일이 빈번하게 발생했습니.
- 심지어 일부 주문은 "이 주문 아예 어디로 갔지?"라는 말이 나올 정도로 흔적 없이 사라지기도 했습니다.

📌 _실제 문제 발생 사례_

- “신년 특가 이벤트” 당시, 한정 수량으로 판매하던 노트북이 이미 품절됐음에도 50대 이상 추가 주문이 접수되어, 전량 환불 조치와 함께 SNS 상에서 부정적인 바이럴이 확산되는 사태가 벌어졌습니다.

---

**📉 비효율 사항 – 반복적 수작업으로 인한 업무 과중과 오류**

고객이 주문을 완료하더라도, 관리자는 이를 별도의 수기 주문서로 정리하고, 재고 수량을 다시 엑셀에 반영해야 했습니다.

- 담당자는 매일 "어제 몇 개 팔았지?"를 묻는 데 대부분의 시간을 소모했고,
- 신규 상품 등록 시에도 기존 엑셀 파일을 복사하고 값을 덮어쓰는 방식으로 관리하다 보니, 포맷 오류나 잘못된 데이터 입력이 끊임없이 발생했습니다.
- 이 모든 과정이 사람 손에 의해 이루어지면서, 업무 효율은 떨어지고 실수가 누적되어 수익 손실로 직결되었습니다.

📌 _실제 문제 발생 사례_

- A사의 물류 담당자는 잘못된 재고 입력으로 인해 30개의 주문이 재고 부족으로 배송 지연되었고, 이로 인한 보상 쿠폰 지급으로 마케팅 비용이 추가로 발생했습니다.

---

**🎯 사용자 니즈 – 고객과 관리자의 경험을 모두 만족시키는 직관적 시스템**

- **고객 측 요구**:
  고객은 온라인 쇼핑의 가장 기본적인 기대치인 “빠르고 간편한 구매 경험”을 원합니다.
  - 상품 검색 → 장바구니 담기 → 결제 → 실시간 주문 상태 확인까지의 전 과정을 최소 클릭으로 처리하고,
  - 주문 이후에는 "내 주문은 지금 어디쯤일까?"를 모바일에서 즉시 확인할 수 있어야 합니다.
  - **관리자 측 요구**:
    관리자는 복잡한 업무를 간소화하고, 상품 등록/수정, 재고 현황, 주문 내역을 하나의 대시보드에서 직관적으로 관리하길 원합니다.
    - 또한, 신규 이벤트 상품 추가, 프로모션 할인 적용, 상품 노출 여부 변경 등을 비개발 인력도 손쉽게 처리할 수 있어야 하며,
    - 주문 현황, 결제 상태, 환불 요청 등의 정보를 실시간으로 확인하고 바로 조치할 수 있는 빠른 워크플로우를 요구합니다.

📌 _실제 요청 기능 예시_

- 고객: "카카오톡으로 배송 상태 알림 받을 수 있나요?"
- 관리자: "신상품 등록하고 나서, 바로 품절 상태로 비활성화할 수 있으면 좋겠어요."

---

**🚀 확장성 요구 – 변화에 유연하게 대응하는 시스템 구조**

- 스타트업의 급성장 특성상, 새로운 요구 사항이 끊임없이 발생할 수밖에 없습니다.
- 단기적으로는 신용카드 외에도 PayPal, 간편결제(네이버페이, 카카오페이) 등의 결제 수단을 추가해야 하고,
- 장기적으로는 해외 직구 서비스, 구독형 결제 모델, 포인트 적립/할인 시스템 도입도 검토 중입니다.

📌 _확장성 요구 예시_

- 결제 수단 추가 시, 기존 코드를 일절 수정하지 않고 새로운 결제 클래스를 추가하는 것만으로 시스템이 동작해야 합니다 (**OCP - 개방-폐쇄 원칙**).
- 새로운 상품 유형(예: 구독형 서비스, 선불카드 상품)이 추가되더라도 기존 주문 처리 로직은 그대로 유지되어야 합니다.

---

**📐 품질 목표 – 유지보수성과 재사용성을 극대화한 설계**

- 단순히 “돌아가기만 하는” 코드로는 빠르게 변화하는 시장에서 생존할 수 없습니다.
- 시스템은 SRP (단일 책임 원칙)에 따라, 각 컴포넌트가 명확한 책임만을 가지도록 분리되어야 하며,
- OCP (개방-폐쇄 원칙)을 철저히 준수하여, 새로운 기능 추가 시 기존 코드는 손대지 않고 확장만으로 대응할 수 있어야 합니다.

이를 통해 유지보수 비용을 최소화하고, 비즈니스 요구 사항 변화에 빠르게 대응할 수 있는 **탄탄한 아키텍처**를 갖추는 것이 궁극적인 목표입니다.

📌 _실무적 기대 효과_

- “결제 수단 추가 요청” → 하루 만에 클래스 하나 추가하고 바로 운영 반영
- “프로모션 상품 노출 방식 변경” → 프론트엔드 설정값만 바꾸면 즉시 반영

---

## 🏗️ **솔루션 개요 및 시스템 설계 철학**

이 프로젝트는 단순한 코드 실습이 아니라, 실제 스타트업 A사의 급격한 성장과 함께 발생한 복잡한 비즈니스 문제를 해결하기 위한 **실제 서비스 환경 수준의 시스템 설계 프로젝트**입니다.

단기간에 폭발적인 주문 증가, 잦은 재고 오류, 고객 불만 급증이라는 문제에 직면한 A사는, 더 이상 수작업 관리로는 생존할 수 없음을 절감하고, **객체지향 프로그래밍(OOP) 원칙**에 따라 유지보수성과 확장성을 모두 갖춘 백엔드 시스템을 구축하기로 결정했습니다.

---

## 📚 **실제 비즈니스 도메인을 반영한 객체 모델링**

이번 프로젝트에서는 실무에서 요구되는 기능과 업무 프로세스를 중심으로, 실제 도메인 모델을 **클래스와 객체로 명확하게 설계**합니다. 모든 시스템 컴포넌트는 향후 기능 추가와 요구사항 변화에 유연하게 대응할 수 있도록 SOLID 원칙(SRP, OCP, LSP, ISP, DIP)을 충실히 반영하여 설계되었습니다.

---

### 📌 **주요 도메인 클래스 설계**

---

### 👤 **사용자 (User)**

- **설계 패턴**: 추상 클래스 + 상속 + 캡슐화 + 권한 분리 (RBAC)
- `User`는 모든 사용자 공통 속성(이름, 비밀번호, 계정 상태)과 로그인/인증 기능을 제공합니다.
- 비밀번호는 Private Field(`#password`)로 철저하게 은닉하며, 외부 노출을 원천 차단합니다.
- 사용자 유형별로 권한을 구분하여, 관리자는 관리자 대시보드 전용 기능, 고객은 마이페이지 및 주문 기능에만 접근할 수 있도록 **역할 기반 권한 관리**를 구현합니다.

**하위 클래스 설계**

- `Customer`:
  - 장바구니 관리, 주문 생성, 알림 설정, 상품 리뷰 작성 기능 제공.
  - 고객 등급에 따라 할인율, 포인트 적립률, 배송비 혜택이 달라지도록 VIP, 일반, 체험 고객으로 확장 가능.
- `Admin`:
  - 상품 등록/수정/삭제, 재고 조정, 주문 현황 관리, 사용자 계정 관리(정지/복구), 대시보드 통계 조회.
  - 물류 관리자, 마케팅 관리자, CS 관리자 등 **세분화된 관리자 권한 체계** 적용 가능.

---

### 📦 **상품 (Product)**

- **설계 패턴**: 추상 클래스 + 다형성 + 정보 은닉 (WeakMap, Symbol)
- `Product`는 공통 속성(상품명, 가격, 고유 ID, 노출 상태, 리뷰 목록)을 관리하며, 상품별 재고 정보는 `WeakMap`으로 철저히 은닉합니다.
- 고유 ID는 `Symbol`로 관리해 외부 노출을 방지하고, 시스템 내부 식별 용도로만 사용합니다.

**하위 클래스 설계**

- `PhysicalProduct`:
  - 실물 상품 관리, 무게·부피 정보에 따른 배송비 계산, 해외 배송 여부, 통관 필요성 관리.
- `DigitalProduct`:
  - 디지털 콘텐츠 관리, DRM 적용, 다운로드 링크 발송, 파일 크기/유효기간 관리.

📌 _실무 적용 사례_

- 실물 상품의 경우, 배송 정책에 따라 새벽 배송, 일반 배송, 해외 배송 등을 자동으로 결정.
- 디지털 상품은 콘텐츠 라이선스 관리, 다운로드 횟수 제한, 구독형 상품 모델로 확장 설계.

---

### 📄 **주문 (Order)**

- **설계 패턴**: 조합 (Composition) + 상태 패턴 + 트랜잭션 관리 + 이벤트 기반 처리
- `Order`는 주문 고유 번호, 주문자 정보, 상품 목록, 결제 정보, 주문 상태, 총 결제 금액을 관리합니다.
- 주문 상태는 `pending`, `completed`, `cancelled`, `failed`로 구분되며, 상태 전환 시 후속 처리(결제, 재고 차감, 배송 요청, 알림 발송)가 자동으로 이루어집니다.

**고급 설계 요소**

- **주문 실패 재시도 로직**: 네트워크 오류, 결제 실패 시 자동 재시도 또는 CS 처리 요청.
- **재고 부족 알림**: 주문 시 재고 부족 발생 시 관리자 대시보드 및 알림 시스템으로 즉시 보고.
- **주문 통계 관리**: 주문 상태별 집계 및 매출 통계 제공, 운영 대시보드 연동.

---

### 💳 **결제 수단 (PaymentMethod)**

- **설계 패턴**: 추상 클래스 + 전략 패턴 (Strategy Pattern) + 다형성
- `PaymentMethod` 추상 클래스는 모든 결제 수단이 반드시 구현해야 할 `processPayment()` 인터페이스를 제공합니다.
- 새로운 결제 수단 추가 시 기존 코드를 수정하지 않고, 새 클래스를 추가하는 것만으로 기능 확장이 가능합니다 (**OCP 완벽 준수**).

**하위 클래스 설계**

- `CreditCardPayment`: 신용카드 결제, 3D 보안 인증, 할부 결제 로직 지원.
- `PayPalPayment`: 해외 결제, 통화 변환, 환불 처리 로직.
- `NaverPayPayment`, `KakaoPayPayment`, `PointPayment`: 간편 결제, 포인트 사용, 할인 쿠폰 결제 등 다양한 확장 가능.

📌 _실무 적용 사례_

- 새로운 이벤트용 한정 결제 수단 추가(예: 특정 카드 전용 할인), 결제 수단 우선 순위 조정, 수수료 정책 변경에 빠르게 대응.

---

### 📊 **전체 시스템 품질 및 확장 전략**

| 도메인  | 실무 고려 요소 및 확장 전략                                 |
| ------- | ----------------------------------------------------------- |
| User    | 관리자 역할 세분화, 고객 등급 시스템, 알림 선호 설정        |
| Product | 상품 유형 추가 (구독형, 선불권), 자동 재고 보충, 품절 관리  |
| Order   | 상태 패턴 활용한 주문 흐름 제어, 트랜잭션 보장, 실패 재시도 |
| Payment | 결제 전략 패턴, 신결제 수단 즉시 도입, 할인/쿠폰 시스템     |

---

이번 시스템 설계를 통해 A사는 향후 결제 수단 추가, 상품 유형 확장, 해외 진출, 구독 서비스 도입 등 다양한 비즈니스 변화에도 코드를 수정하지 않고, 새로운 클래스를 추가하는 것만으로 빠르게 시장에 대응할 수 있는 **탄탄한 OOP 기반 아키텍처**를 갖추게 됩니다. 🚀

---

## 📌 **주요 설계 원칙 적용 상세**

1. **🔒 캡슐화 (Encapsulation)**
   - 민감한 데이터(예: 사용자 비밀번호, 상품 재고 정보)는 외부에서 직접 접근하지 못하도록 철저히 보호합니다.
   - `#password` (Private Field), `WeakMap` (재고 은닉), `Symbol` (상품 고유 ID 비공개) 등을 활용해 정보 은닉을 강화하고, 의도치 않은 데이터 조작을 방지합니다.
2. **🏷️ 상속 (Inheritance)**
   - 공통 속성과 기능은 추상 클래스(`User`, `Product`, `PaymentMethod`)에 정의하고, 하위 클래스에서 구체적인 행동을 구현합니다.
   - 예시:
     - `User` → `Customer`, `Admin`
     - `Product` → `PhysicalProduct`, `DigitalProduct`
3. **🔀 다형성 (Polymorphism)**
   - `Product.deliver()` 메서드는 상품 유형에 따라 서로 다른 배송 방식(실물 배송, 디지털 다운로드)을 실행합니다.
   - 결제 수단은 `PaymentMethod` 추상 클래스를 통해 다양한 방식으로 처리하며, 새로운 결제 수단 추가 시 기존 로직 변경 없이 확장됩니다.
4. **📚 단일 책임 원칙 (SRP)**
   - 각 클래스는 명확한 역할과 책임만을 담당하도록 설계되어, 코드 변경 시 영향 범위를 최소화합니다.
   - 예시:
     - 사용자 관리: `User` 계열
     - 상품 관리: `Product` 계열
     - 주문 처리: `Order`
     - 결제 처리: `PaymentMethod` 계열
5. **📈 개방-폐쇄 원칙 (OCP)**
   - 시스템은 확장에는 열려 있고, 수정에는 닫혀 있도록 설계되었습니다.
   - 새로운 결제 수단이나 상품 유형 추가 시, 기존 코드를 변경하지 않고 새 클래스를 추가하는 것만으로 시스템이 자연스럽게 확장됩니다.

---

# 📌 **주요 기능 정의 및 역할 분담**

### 👤 **고객(Customer) 기능**

| 기능              | 설명                                                       |
| ----------------- | ---------------------------------------------------------- |
| 상품 조회         | 카테고리, 키워드, 가격대 필터링 지원                       |
| 장바구니 관리     | 상품 추가/삭제, 수량 변경, 총 금액 실시간 계산             |
| 주문 생성 및 결제 | 장바구니 상품으로 주문 생성, 다양한 결제 수단 지원         |
| 주문 상태 확인    | 주문 상태(`pending`, `completed`, `cancelled`) 실시간 조회 |
| 리뷰 작성         | 구매 완료 상품에 대한 리뷰 작성 및 평점 부여               |
| 알림 설정 변경    | 이메일, SMS, 푸시 알림 수신 여부 설정                      |

---

### 🛠️ **관리자(Admin) 기능**

| 기능                | 설명                                                     |
| ------------------- | -------------------------------------------------------- |
| 상품 등록/수정/삭제 | 상품 정보 입력, 수정, 삭제 및 노출 여부 관리             |
| 재고 관리           | 상품별 재고 수량 확인 및 변경, 임계치 도달 시 알림       |
| 사용자 계정 관리    | 계정 정지, 복구 처리, 사용자 상태 조회                   |
| 주문 현황 관리      | 주문 상태 모니터링, 결제 실패/취소 처리                  |
| 대시보드 통계       | 매출, 주문 현황, 결제 수단 이용 현황 등 통계 데이터 조회 |

---

### 📦 **상품(Product) 기능**

| 기능                | 설명                                                   |
| ------------------- | ------------------------------------------------------ |
| 상품 정보 관리      | 상품명, 가격, 고유 ID, 노출 여부, 리뷰 목록 관리       |
| 리뷰 작성/평점 계산 | 고객 리뷰 추가, 평균 평점 실시간 계산                  |
| 배송 방식 구현      | 실물 상품: 택배 배송 / 디지털 상품: 다운로드 링크 발송 |

---

### 📄 **주문(Order) 기능**

| 기능           | 설명                                                   |
| -------------- | ------------------------------------------------------ |
| 주문 생성      | 장바구니 상품으로 주문 인스턴스 생성                   |
| 결제 처리      | 다양한 결제 수단을 통한 결제, 실패 시 재시도 로직 적용 |
| 상태 관리      | 주문 상태 전환 (pending → completed/cancelled)         |
| 재고 자동 차감 | 결제 완료 시 상품별 재고 자동 차감 처리                |

---

### 💳 **결제(PaymentMethod) 기능**

| 기능           | 설명                                                   |
| -------------- | ------------------------------------------------------ |
| 결제 수단 처리 | 신용카드, PayPal, 포인트 등 다양한 결제 수단 지원      |
| 결제 확장성    | 새로운 결제 수단 추가 시 기존 코드 수정 없이 확장 가능 |
| 결제 실패 처리 | 네트워크 오류, 인증 실패 시 재시도 및 실패 로그 기록   |

---

# 📖 **기능 흐름 시나리오 (실제 사용 예시)**

---

### 📦 **고객 시나리오 – 상품 구매 전체 플로우**

1. 고객 A는 로그인 후 최신 상품 목록을 조회하고, 관심 있는 상품을 장바구니에 추가합니다.
2. 결제 단계에서 신용카드 또는 PayPal을 선택해 결제를 진행합니다.
3. 주문이 성공적으로 완료되면, 상품 재고는 자동 차감되고, 주문 상태는 `completed`로 전환됩니다.
4. 고객은 마이페이지에서 주문 상태와 예상 배송 일정을 실시간으로 확인할 수 있습니다.
5. 상품 수령 후, 리뷰를 작성하고 평점을 남겨 다른 고객과 경험을 공유합니다.

---

### 🏢 **관리자 시나리오 – 상품 및 주문 관리**

1. 관리자 B는 관리 콘솔에 로그인하여 신상품을 등록하고, 초기 재고 수량을 입력합니다.
2. 주문이 접수되면 관리자는 주문 현황 페이지에서 결제 상태와 재고 소진 상태를 확인합니다.
3. 특정 상품이 재고 임계치 이하로 떨어지면, 시스템이 관리자에게 재고 보충 알림을 발송합니다.
4. CS 요청으로 고객 계정을 일시 정지하거나 복구하고, 비정상적인 주문 패턴을 확인해 적절한 조치를 취합니다.

---

# ✅ **결론: 고도화된 OOP 설계를 통한 시스템 안정성과 확장성 확보**

이번 프로젝트는 단순한 쇼핑몰 구현을 넘어, **실제 상업 환경에서 요구되는 확장성, 유지보수성, 보안성**을 모두 고려한 **완성도 높은 객체지향 시스템**으로 설계되었습니다.

✔ **유지보수성**:

- SRP와 OCP 원칙을 적용하여, 새로운 요구 사항에도 최소한의 코드 수정으로 빠르게 대응할 수 있습니다.

✔ **확장성**:

- 상품 유형, 결제 수단, 사용자 역할 등 다양한 비즈니스 확장 요구에 대비한 유연한 클래스 구조를 구현하였습니다.

✔ **보안성**:

- 민감한 정보는 `#Private Fields`, `WeakMap`, `Symbol` 등을 활용해 철저하게 보호하며, 외부 직접 접근을 차단했습니다.

📌 **실제 레퍼런스 모델**

- 대형 이커머스 기업인 **아마존, 쿠팡, 이베이** 등도 이와 유사한 도메인 모델링과 객체지향 설계를 기반으로 복잡한 시스템을 안정적으로 운영하고 있습니다.

---

# **📦 전체 코드: E-Commerce Product Processing System (Complete Code + Tests)**

```jsx
// =====================================
// 📦 E-Commerce Product Processing System (Complete Code + Tests)
// =====================================

// ✅ [모듈 스코프] 완전한 캡슐화를 위한 심볼과 WeakMap 사용
const INTERNAL_ID = Symbol("internalId"); // 상품 고유 ID (외부 노출 금지)
const stockData = new WeakMap(); // 상품 재고 정보 (외부 직접 접근 금지)

// =====================================
// 👤 [추상 클래스] User (Customer, Admin 공통 기능)
// =====================================
class User {
  #password; // 비밀번호 은닉 (Private Field)

  constructor(name, password) {
    if (new.target === User) {
      throw new Error(
        "User는 추상 클래스입니다. 직접 인스턴스화할 수 없습니다."
      );
    }
    this.name = name;
    this.#password = password;
    this.isSuspended = false; // 계정 정지 여부
  }

  // ✅ 로그인 메서드: 비밀번호 검증 및 계정 정지 여부 체크
  login(inputPw) {
    if (this.isSuspended) {
      console.log(`🚫 ${this.name} 계정은 정지되었습니다. 로그인 실패.`);
      return false;
    }
    if (inputPw === this.#password) {
      console.log(`✅ ${this.name}님, 로그인 성공!`);
      return true;
    }
    console.log(`❌ ${this.name}님, 비밀번호가 틀렸습니다.`);
    return false;
  }
}

// =====================================
// 🛒 Customer (일반 사용자)
// =====================================
class Customer extends User {
  constructor(name, password) {
    super(name, password);
    this.cart = []; // 장바구니 (상품 목록)
    this.notifications = { email: true, sms: true, push: true }; // 알림 설정
  }

  // ✅ 장바구니에 상품 추가
  addToCart(product) {
    if (!product.isVisible || (stockData.get(product) ?? 0) <= 0) {
      console.log(`📛 "${product.name}" 상품은 구매할 수 없습니다.`);
      return;
    }
    this.cart.push(product);
    console.log(`🛒 "${product.name}" 장바구니에 추가되었습니다.`);
  }

  // ✅ 장바구니 상품으로 주문 생성
  createOrder() {
    if (this.cart.length === 0) {
      console.log(`🛍️ 장바구니가 비어있습니다. 주문할 수 없습니다.`);
      return null;
    }
    const order = new Order(this, this.cart);
    this.cart = []; // 장바구니 비우기
    return order;
  }

  // ✅ 상품 리뷰 작성
  reviewProduct(product, rating, comment) {
    product.addReview(this, rating, comment);
    console.log(
      `✍️ ${this.name}님이 "${product.name}"에 리뷰를 남겼습니다. 평점: ${rating} / 내용: "${comment}"`
    );
  }

  // ✅ 알림 설정 변경
  updateNotificationPreference(type, value) {
    if (this.notifications.hasOwnProperty(type)) {
      this.notifications[type] = value;
      console.log(`🔔 ${this.name}님의 ${type} 알림 설정: ${value}`);
    } else {
      console.log(`⚠️ 알림 유형 "${type}"은 잘못되었습니다.`);
    }
  }
}

// =====================================
// 🛠️ Admin (관리자)
// =====================================
class Admin extends User {
  constructor(name, password) {
    super(name, password);
  }

  // ✅ 상품 추가
  addProduct(product, stock) {
    stockData.set(product, stock);
    Product.catalog.push(product);
    console.log(
      `📦 관리자 ${this.name}님이 "${product.name}"을(를) 추가했습니다. 재고: ${stock}`
    );
  }

  // ✅ 재고 변경
  changeStock(product, newStock) {
    if (!stockData.has(product)) {
      console.log(`🚫 "${product.name}" 상품은 관리 대상이 아닙니다.`);
      return;
    }
    stockData.set(product, newStock);
    console.log(`📈 "${product.name}" 재고가 ${newStock}개로 변경되었습니다.`);
  }

  // ✅ 재고 확인
  checkStock(product) {
    return stockData.get(product) ?? 0;
  }

  // ✅ 상품 노출 상태 토글
  toggleProductVisibility(product) {
    product.isVisible = !product.isVisible;
    console.log(`👀 "${product.name}" 표시 여부: ${product.isVisible}`);
  }

  // ✅ 상품 삭제
  deleteProduct(product) {
    Product.catalog = Product.catalog.filter((p) => p !== product);
    stockData.delete(product);
    console.log(`🗑️ "${product.name}" 상품이 카탈로그에서 삭제되었습니다.`);
  }

  // ✅ 사용자 계정 정지
  suspendCustomer(user) {
    if (user instanceof User) {
      user.isSuspended = true;
      console.log(`⛔ 사용자 ${user.name} 계정이 정지되었습니다.`);
    }
  }

  // ✅ 사용자 계정 복구
  reinstateCustomer(user) {
    if (user instanceof User) {
      user.isSuspended = false;
      console.log(`✅ 사용자 ${user.name} 계정이 복구되었습니다.`);
    }
  }
}

// =====================================
// 📦 [추상 클래스] Product
// =====================================
class Product {
  static catalog = [];
  static nextId = 1;

  constructor(name, price) {
    if (new.target === Product) {
      throw new Error("Product는 추상 클래스입니다.");
    }
    this.name = name;
    this.price = price;
    this[INTERNAL_ID] = Product.nextId++;
    this.isVisible = true;
    this.reviews = [];
  }

  // ✅ 상품 배송 (추상 메서드, 서브 클래스에서 구현 필요)
  deliver(toUser) {
    throw new Error("서브 클래스에서 deliver()를 반드시 구현해야 합니다.");
  }

  // ✅ 카탈로그 출력
  static printCatalog() {
    console.log(`\n📚 [현재 상품 카탈로그]`);
    for (const p of Product.catalog) {
      const stock = stockData.get(p) ?? 0;
      const visibility = p.isVisible ? "" : "(숨김 처리됨) ";
      console.log(
        `- ${p.name} | 💰 ${p.price}원 | 📦 재고: ${stock} | ${visibility}`
      );
    }
  }

  // ✅ 리뷰 추가
  addReview(customer, rating, comment) {
    this.reviews.push({ user: customer.name, rating, comment });
  }

  // ✅ 평균 평점 계산
  getAverageRating() {
    if (this.reviews.length === 0) return 0;
    const sum = this.reviews.reduce((acc, r) => acc + r.rating, 0);
    return sum / this.reviews.length;
  }
}

// =====================================
// 📦 PhysicalProduct (실물 상품)
// =====================================
class PhysicalProduct extends Product {
  constructor(name, price, weight) {
    super(name, price);
    this.weight = weight;
  }

  // ✅ 실물 상품 배송
  deliver(toUser) {
    console.log(
      `📦 "${this.name}" 상품이 ${toUser.name}님께 택배로 배송됩니다. (무게: ${this.weight}kg)`
    );
  }
}

// =====================================
// 📧 DigitalProduct (디지털 상품)
// =====================================
class DigitalProduct extends Product {
  constructor(name, price, fileSize) {
    super(name, price);
    this.fileSize = fileSize;
  }

  // ✅ 디지털 상품 전송
  deliver(toUser) {
    console.log(
      `📧 "${this.name}" 다운로드 링크가 ${toUser.name}님께 이메일로 발송되었습니다. (파일 크기: ${this.fileSize}MB)`
    );
  }
}

// =====================================
// 📄 Order (주문)
// =====================================
class Order {
  static nextOrderId = 1;

  constructor(customer, products) {
    this.id = Order.nextOrderId++;
    this.customer = customer;
    this.products = [...products];
    this.totalPrice = products.reduce((sum, p) => sum + p.price, 0);
    this.status = "pending";
  }

  // ✅ 주문 결제 및 상품 배송
  checkout(paymentMethod) {
    if (this.status !== "pending") {
      console.log(
        `🚫 주문 ${this.id}은 처리할 수 없습니다. 현재 상태: ${this.status}`
      );
      return;
    }
    paymentMethod.processPayment(this.totalPrice);
    for (const p of this.products) {
      p.deliver(this.customer);
      if (stockData.has(p)) {
        const currentStock = stockData.get(p);
        stockData.set(p, currentStock - 1);
      }
    }
    this.status = "completed";
    console.log(
      `✅ 주문 ${this.id}이 완료되었습니다. 총 결제 금액: 💰 ${this.totalPrice}원`
    );
  }

  // ✅ 주문 취소
  cancel() {
    if (this.status !== "pending") {
      console.log(
        `🚫 주문 ${this.id}은 취소할 수 없습니다. 현재 상태: ${this.status}`
      );
      return;
    }
    this.status = "cancelled";
    console.log(`❌ 주문 ${this.id}이 취소되었습니다.`);
  }
}

// =====================================
// 💳 [추상 클래스] PaymentMethod (결제 수단 인터페이스)
// =====================================
class PaymentMethod {
  processPayment(amount) {
    throw new Error("processPayment()는 반드시 구현해야 합니다.");
  }
}

// =====================================
// 💳 CreditCardPayment (신용카드 결제)
// =====================================
class CreditCardPayment extends PaymentMethod {
  processPayment(amount) {
    console.log(`💳 신용카드로 ${amount}원 결제가 처리되었습니다.`);
  }
}

// =====================================
// 💰 PayPalPayment (PayPal 결제)
// =====================================
class PayPalPayment extends PaymentMethod {
  processPayment(amount) {
    console.log(`💰 PayPal로 ${amount}원 결제가 처리되었습니다.`);
  }
}

// =====================================
// ✅ 테스트 시나리오
// =====================================

// 1) 관리자 Alice가 상품 추가
const adminAlice = new Admin("Alice", "admin123");
const laptop = new PhysicalProduct("Laptop", 1500, 2.5);
const ebook = new DigitalProduct("E-Book", 30, 150);
adminAlice.addProduct(laptop, 5);
adminAlice.addProduct(ebook, 100);
Product.printCatalog();

// 2) 고객 Bob이 로그인 및 장바구니에 담기
const customerBob = new Customer("Bob", "pass1234");
customerBob.login("pass1234");
customerBob.addToCart(laptop);
customerBob.addToCart(ebook);

// 3) 주문 생성 및 결제 (신용카드)
const order1 = customerBob.createOrder();
if (order1) order1.checkout(new CreditCardPayment());
Product.printCatalog();

// 4) 관리자 재고 확인 및 보충
console.log(
  `Remaining stock of Laptop: ${adminAlice.checkStock(laptop)} units`
);
adminAlice.changeStock(laptop, 10);
adminAlice.changeStock(ebook, 120);
Product.printCatalog();

// 5) 주문 취소 테스트
if (order1) order1.cancel(); // 실패: 이미 완료됨
customerBob.addToCart(laptop);
const order2 = customerBob.createOrder();
if (order2) order2.cancel(); // 성공: pending 상태

// 6) 리뷰 작성 및 평점 확인
customerBob.reviewProduct(laptop, 5, "Excellent quality!");
console.log(
  `Average rating of ${laptop.name}: ${laptop
    .getAverageRating()
    .toFixed(1)} stars`
);

// 7) 상품 숨김 및 삭제
adminAlice.toggleProductVisibility(ebook);
Product.printCatalog();
adminAlice.deleteProduct(ebook);
Product.printCatalog();

// 8) 계정 정지/복구 테스트
adminAlice.suspendCustomer(customerBob);
customerBob.login("pass1234"); // 실패
adminAlice.reinstateCustomer(customerBob);
customerBob.login("pass1234"); // 성공

// 9) PayPal 결제 테스트
customerBob.addToCart(laptop);
const order3 = customerBob.createOrder();
if (order3) order3.checkout(new PayPalPayment());
Product.printCatalog();
```

---

# 📚 **전체 코드 파트별 OOP 전략 및 내부 로직 상세 해설**

---

## ✅ [1. 모듈 스코프 변수: 캡슐화와 정보 은닉]

```jsx
const INTERNAL_ID = Symbol("internalId");
const stockData = new WeakMap();
```

### **📚 적용된 OOP 전략**:

- ✅ **캡슐화 (Encapsulation)**
- ✅ **정보 은닉 (Data Hiding)**

### 🔍 **내부 동작 상세 설명**

- `INTERNAL_ID`
  - 상품에만 부여되는 **고유 식별자**입니다.
  - `Symbol`을 사용했기 때문에 외부에서 프로퍼티 키를 알아도 직접 접근이 불가능합니다.
  - 이는 실무에서 민감한 데이터(예: 상품의 내부 관리 코드)를 외부에 노출하지 않고, 시스템 내부 추적에만 활용하는 방식과 같습니다.
- `stockData`
  - **WeakMap**을 사용하여 상품 객체와 재고 수량을 1:1로 매핑해 관리합니다.
  - WeakMap의 키인 객체가 더 이상 참조되지 않으면, 해당 재고 정보도 메모리에서 자동으로 제거됩니다.
  - 외부에서는 반드시 Admin 클래스의 전용 메서드를 통해서만 재고 정보에 접근할 수 있도록 철저하게 차단됩니다.

### 📖 **추가 설명: 왜 이렇게 설계했는가?**

- 상품 식별자와 재고 정보는 시스템 내부에서만 의미가 있으며, 외부에 노출될 경우 보안 위험 또는 비즈니스 로직 왜곡 문제가 발생할 수 있습니다.
- 예를 들어, 클라이언트 사이드에서 제품 ID가 노출되면 불법적인 주문 조작이나 API 호출 시도가 발생할 수 있습니다.
- 또한, 재고 정보를 직접 접근할 수 있게 하면 비정상적인 재고 조작, 가격 오류, 품절 상태 미반영 등 심각한 비즈니스 문제가 발생할 수 있습니다.
- 이러한 이유로, **철저한 데이터 은닉과 캡슐화**를 통해 시스템의 안정성과 보안성을 확보합니다.

### 📌 **실무 적용 사례**

- **네이버 스마트스토어**: 과거 상품 관리 시스템에서 상품 고유 ID가 외부 API 응답에 노출되어, 악의적인 사용자가 비공식 API를 호출해 상품 가격을 조작하려 한 사례가 있었습니다. 이를 방지하기 위해 고유 ID를 내부용으로 전환하고, 외부에는 안전한 UUID와 별도의 공개 키를 제공하는 구조로 개선하였습니다.
- **쿠팡 관리자 시스템**: 상품 재고 정보는 반드시 관리자 전용 API를 통해서만 조회·수정할 수 있도록 설계되었습니다. 일반 사용자 또는 비인가 사용자는 재고 정보에 절대 접근할 수 없으며, 모든 재고 변경 요청은 감사 로그와 함께 기록되어 문제 발생 시 추적할 수 있도록 구현하였습니다.

### 💡 **설계 의사결정 트레이드오프**

- `WeakMap`은 메모리 관리 측면에서는 매우 유리합니다. 상품 객체가 더 이상 필요 없을 때, 재고 정보도 함께 자동으로 메모리에서 해제되어 **메모리 누수 방지**에 효과적입니다.
- 그러나, **영구적인 재고 정보 유지가 필요한 경우** WeakMap만으로는 충분하지 않습니다. 시스템 재시작 시 재고 정보가 모두 사라지기 때문에, 이를 방지하려면 **데이터베이스 연동** 또는 **영속성 계층**이 반드시 필요합니다.
- 📌 실무에서는 다음과 같은 전략을 사용합니다:
  - 운영 환경: DB와 연동한 재고 관리 (MySQL, Redis, MongoDB 등)
  - 개발/테스트 환경: WeakMap으로 메모리 내 테스트 용도 사용
- 또한, 고급 설계에서는 `캐시 계층 (Redis)`를 두고, 실시간 재고 변동은 캐시에, 정산 시에는 DB에 동기화하는 하이브리드 전략도 널리 사용됩니다.

---

## ✅ [2. User 클래스: 추상 클래스, 정보 보호, 공통 인터페이스 제공]

```jsx
class User {
    #password;

    constructor(name, password) { ... }
    login(inputPw) { ... }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **추상 클래스 (Abstract Class)**: 직접 인스턴스화 방지, 공통 속성과 메서드 제공
- ✅ **상속 (Inheritance)**: 공통 로직은 User에서 관리, 하위 클래스(Customer, Admin)에서 확장
- ✅ **캡슐화 (Encapsulation)**: 민감한 정보(비밀번호)를 외부에서 접근하지 못하도록 보호

---

### 🔍 **내부 동작 상세 설명**

- `#password` (Private Field)
  - **기능**: 사용자 비밀번호를 외부로부터 완전하게 은닉합니다.
  - 📌 **설계 의도**:
    - ES6 Private Fields(`#`)를 활용해 외부 접근을 원천적으로 차단하고, 의도하지 않은 정보 노출 및 변경을 방지합니다.
    - 실무에서는 보안 취약점을 방지하기 위해 비밀번호는 항상 해시 처리된 상태로 별도의 저장소(DB)에 보관하며, 코드 상에서도 직접 노출하지 않도록 합니다.
- `constructor(name, password)`
  - **기능**: 사용자 이름과 비밀번호를 초기화하고, 계정 상태를 기본값으로 설정합니다.
  - 📌 **설계 의도**:
    - `new.target`을 활용해 User 클래스의 직접 인스턴스화를 방지하고, 반드시 Customer, Admin과 같은 구체 클래스를 통해 인스턴스가 생성되도록 강제합니다.
    - 이는 실무에서도 **객체 생성을 제어**하고, 잘못된 객체 생성으로 인한 시스템 오류를 방지하는 데 중요한 설계 패턴입니다.
- `login(inputPw)`
  - **기능**: 사용자의 계정 상태와 비밀번호를 검증하고, 로그인 결과를 반환합니다.
  - 📌 **설계 의도**:
    - 비밀번호는 외부에서 직접 비교하거나 조회할 수 없고, 오직 `login` 메서드를 통해서만 검증하도록 하여 **보안성을 극대화**합니다.
    - 계정 정지 상태 검사를 통해 시스템 운영 정책(이용 약관 위반, 악성 사용자 제재 등)이 정확히 반영됩니다.
    - 실무에서는 로그인 실패 횟수 제한, 계정 잠금, OTP/2FA 등 추가적인 보안 절차와도 연계됩니다.

---

### 📖 **왜 이런 방식을 선택했는가?**

- 사용자 계정 정보는 시스템 내에서 가장 민감하고 중요한 데이터입니다.
- 비밀번호는 반드시 암호화되어 저장되고, 외부 노출을 철저히 차단해야 하며, 이를 위해 ES6 Private Fields와 OOP 캡슐화 개념을 적극 활용합니다.
- 추상 클래스 설계는 사용자 유형에 따른 역할 분리를 명확하게 하여, 시스템이 확장될 때도 일관된 인터페이스와 안정적인 로직 흐름을 유지할 수 있도록 지원합니다.

---

### 📌 **실무 적용 사례**

- **카카오 계정 시스템**:
  - 사용자 비밀번호는 절대 클라이언트 측에서 전송되지 않고, 해시 처리된 값만 서버에서 관리합니다.
  - 관리자/사용자 구분을 명확히 하여, 권한별로 전용 시스템 접근만 허용하며, 계정 정지, 복구 기능은 관리자 시스템에 별도로 분리되어 제공됩니다.
- **AWS IAM (Identity and Access Management)**:
  - 사용자 유형에 따라 역할(Role)과 권한(Policy)을 명확히 분리합니다.
  - 직접 인스턴스화를 방지하고, 반드시 Role/Policy를 통해 사용자를 관리하도록 설계되어 있습니다.
- **토스 결제 시스템**:
  - 민감한 정보인 결제 비밀번호는 서버에서도 직접 접근하지 않고, OTP, SMS 인증 등 다단계 검증 과정을 거칩니다.
  - 계정 정지/복구 로직은 고객 지원팀 전용 콘솔에서만 접근 가능하며, 감사 로그를 남깁니다.

---

### 💡 **설계 의사결정 트레이드오프**

| 선택사항            | 장점                            | 단점                                            |
| ------------------- | ------------------------------- | ----------------------------------------------- |
| Private Fields 사용 | 보안성 극대화, 접근 완전 차단   | ES6 이상 환경 필요, 외부 라이브러리 일부 미지원 |
| 추상 클래스 사용    | 공통 로직 재사용, 구조화된 설계 | 추상 클래스 직접 인스턴스화 방지 추가 코드 필요 |
| 로그인 로직 분리    | 단일 책임 원칙 준수             | 보안 강화 시 로직 복잡성 증가                   |

- 📌 **보완 설계**
  - 실무에서는 비밀번호를 단순히 필드로 보관하지 않고, 반드시 **Hashing(SHA-256, bcrypt)**을 적용합니다.
  - 로그인 실패 횟수 제한, 자동 잠금, OTP 인증, CAPTCHA 등의 보안 기능을 추가해 방어적 프로그래밍을 강화합니다.
  - 비밀번호 관리 로직은 별도의 `PasswordManager` 유틸리티 클래스로 분리해, 암호화/복호화, 유효성 검증 등을 전담하도록 설계하는 것이 바람직합니다.

---

## ✅ [3. Customer 클래스: 조합, 정보 은닉, 사용자 행동 관리]

```jsx
class Customer extends User {
    constructor(name, password) { ... }
    addToCart(product) { ... }
    createOrder() { ... }
    reviewProduct(product, rating, comment) { ... }
    updateNotificationPreference(type, value) { ... }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **상속 (Inheritance)**: User 추상 클래스로부터 공통 속성과 메서드를 상속받아 고객 전용 기능 추가
- ✅ **조합 (Composition)**: 고객 객체가 장바구니(cart)와 알림 설정 객체를 내부에 조합하여 관리
- ✅ **캡슐화 (Encapsulation)**: 장바구니, 알림 설정 등 내부 상태는 메서드를 통해서만 안전하게 조작

---

### 🔍 **내부 동작 상세 설명**

- `addToCart(product)`
  - **메서드 기능**: 상품을 장바구니에 추가하는 기능입니다.
  1. 상품이 노출 상태(`isVisible`)인지, 재고가 1개 이상인지 확인합니다.
  2. 조건을 만족하지 않으면 "추가 불가" 메시지 출력 후 종료합니다.
  3. 조건을 만족하면 `this.cart`에 상품을 추가하고, 성공 로그를 출력합니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - \*조합(Composition)\*\*을 사용하여 고객 객체가 자신의 장바구니 상태를 독립적으로 관리합니다.
    - 실무에서는 재고 부족, 품절 상품 장바구니 추가 방지, 장바구니 자동 비우기 등의 로직에 사용됩니다.

---

- `createOrder()`
  - **메서드 기능**: 장바구니에 담긴 상품들로 주문을 생성하는 기능입니다.
  1. 장바구니가 비어 있으면 주문 생성을 거부하고 안내 메시지를 출력합니다.
  2. 장바구니에 상품이 있으면 `Order` 인스턴스를 생성하고, 장바구니를 비웁니다.
  3. 생성된 주문 객체를 반환합니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 고객 행동 흐름(상품 담기 → 주문 생성 → 결제)을 자연스럽게 연결하고, 사용자 경험을 향상시킵니다.
    - 실무에서는 주문 생성 시 포인트 사용, 할인 쿠폰 적용, 주문 이력 기록과도 연계됩니다.

---

- `reviewProduct(product, rating, comment)`
  - **메서드 기능**: 상품에 대한 리뷰 작성 기능입니다.
  1. 전달받은 상품 객체의 `addReview` 메서드를 호출하여 리뷰 정보를 추가합니다.
  2. 리뷰 작성 완료 메시지를 출력합니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 고객이 직접 상품 경험을 시스템에 반영할 수 있어, 리뷰 기반 추천 시스템 구현에 활용됩니다.
    - 실무에서는 후기 작성 시 포인트 지급, 리뷰 검증, 허위 리뷰 필터링 등과도 연계됩니다.

---

- `updateNotificationPreference(type, value)`
  - **메서드 기능**: 고객 알림 설정을 업데이트하는 기능입니다.
  1. 알림 유형이 `email`, `sms`, `push` 중 유효한지 검사합니다.
  2. 유효하지 않으면 경고 메시지를 출력하고 종료합니다.
  3. 유효한 경우 설정 값을 업데이트하고 결과를 출력합니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - **캡슐화**를 통해 알림 설정 값을 안전하게 관리하며, 잘못된 설정으로 인한 문제를 사전에 방지합니다.
    - 실무에서는 맞춤형 마케팅, 할인 쿠폰 알림, 배송 상태 알림 등에 활용되고, 개인정보 보호법 및 정보통신망법 등 법적 준수를 위해 철저하게 관리됩니다.

---

📌 **실무 적용 사례 총정리**:

- 대부분의 이커머스 플랫폼에서 사용자 활동 관리, 맞춤형 알림 제공, 장바구니 유지 등 고객 경험 향상을 위한 핵심 구조입니다.
- 회원 등급제, 포인트 적립, 알림 서비스(카카오 알림톡, 푸시 알림) 등 다양한 부가 기능과도 쉽게 확장 가능합니다.
- **쿠팡 (Coupang)**
  - 고객 장바구니 정보는 서버 세션과 DB에 동기화되어, 모바일 앱과 웹에서 동일하게 유지됩니다.
  - 품절 상품은 장바구니에서 자동으로 제거되며, 푸시 알림을 통해 재입고 알림 기능도 제공합니다.
- **네이버 스마트스토어**
  - 최근 본 상품과 장바구니 정보를 활용해 맞춤형 배너 광고, 이메일 리마인더 마케팅을 자동화합니다.
  - 사용자 알림 설정은 법적 준수 및 사용자 동의에 따라 철저히 관리되며, 마케팅 활용 시 명확한 동의 절차가 필요합니다.
- **Amazon**
  - 고객 장바구니에 담긴 상품에 할인이나 가격 변동이 있을 경우, 즉시 이메일 및 푸시 알림으로 알려 구매 전환율을 높입니다.
  - 고객 행동 분석을 통해 개인화 추천, 관심 상품 알림, 자동 장바구니 비우기 로직도 운영합니다.

---

💡 **설계 의사결정 트레이드오프**

| 선택 사항              | 장점                                   | 단점                                         |
| ---------------------- | -------------------------------------- | -------------------------------------------- |
| 조합(Composition) 사용 | 장바구니와 알림 설정을 독립적으로 관리 | 객체 간 의존성 증가, 상태 추적 필요          |
| 직접 필드 접근 차단    | 데이터 무결성 보장, 보안 강화          | 관리 메서드 코드 증가, 유지비용 상승         |
| 알림 설정 로컬 관리    | 빠른 처리 속도, 사용자 경험 향상       | 서버 동기화 필요, 동기화 지연 시 불일치 가능 |
| 장바구니 세션 저장     | 속도 빠름, 서버 부하 감소              | 세션 만료 시 데이터 유실, 재로그인 필요      |

📌 **보완 설계 제안**

- 장바구니 데이터는 Redis와 같은 인메모리 캐시 시스템을 활용하여 빠른 접근성과 세션 유지성을 높일 수 있습니다.
- 알림 설정은 DB와 실시간 캐시 시스템에 동기화하여, 마케팅 캠페인 시 정확한 타겟팅과 법적 준수를 동시에 만족하도록 설계합니다.
- 장바구니 데이터 유실 방지를 위해, 자동 저장 주기와 백업 로직을 포함하는 것이 바람직합니다.
- 마케팅 알림은 알림 동의 상태에 따라 타겟팅 대상자를 필터링하고, 관련 법령을 준수하는 감사 로그 기록 체계를 함께 마련해야 합니다.

---

## ✅ [4. Admin 클래스: 권한 분리, 단일 책임 원칙, 데이터 검증]

```jsx
class Admin extends User {
    constructor(name, password) { ... }
    addProduct(product, stock) { ... }
    changeStock(product, newStock) { ... }
    checkStock(product) { ... }
    toggleProductVisibility(product) { ... }
    deleteProduct(product) { ... }
    suspendCustomer(user) { ... }
    reinstateCustomer(user) { ... }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **상속 (Inheritance)**: User 추상 클래스로부터 공통 속성(이름, 비밀번호)과 로그인 기능을 상속받습니다.
- ✅ **권한 분리 (Access Control)**: 고객과 관리자의 권한을 명확히 구분하여, 시스템 보안을 강화합니다.
- ✅ **단일 책임 원칙 (SRP)**: Admin 클래스는 오직 시스템 관리와 관련된 책임만을 가집니다.
- ✅ **캡슐화 (Encapsulation)**: 상품 재고, 사용자 상태 등 민감한 정보를 메서드를 통해서만 간접적으로 관리하도록 설계합니다.

---

### 🔍 **내부 동작 상세 설명**

- `addProduct(product, stock)`
  - **기능**: 새로운 상품을 시스템에 등록하고, 초기 재고를 설정합니다.
  1. 상품 객체와 초기 재고 수량을 전달받아 등록합니다.
  2. `stockData` WeakMap에 상품과 재고를 저장합니다.
  3. `Product.catalog`에 상품을 추가하고 성공 메시지 출력.
  - 📌 **설계 의도**:
    - **권한 분리**를 통해 중요한 시스템 데이터 조작은 반드시 관리자를 통해서만 처리합니다.
    - 실무에서는 ERP, 쇼핑몰 관리자 페이지에서 관리자만 상품 정보를 등록할 수 있도록 RBAC(Role-Based Access Control) 체계를 적용합니다.

---

- `changeStock(product, newStock)`
  - **기능**: 기존 상품의 재고를 새로운 값으로 변경합니다.
  1. `stockData`에 상품 존재 여부를 검사합니다.
  2. 존재하지 않으면 경고 후 종료, 있으면 새 재고로 갱신 후 로그 출력.
  - 📌 **설계 의도**:
    - 민감한 데이터인 재고 정보는 반드시 검증된 관리자 인터페이스를 통해서만 변경됩니다.
    - 실무에서는 **입력값 검증 로직**과 함께, 재고 수량이 음수가 되지 않도록 방지하고, 재고 변경 로그를 DB에 저장하는 경우가 많습니다.

---

- `checkStock(product)`
  - **기능**: 특정 상품의 현재 재고 정보를 반환합니다.
  - 📌 **설계 의도**:
    - 외부에서는 재고 정보를 직접 접근할 수 없고, 반드시 이 메서드를 통해 안전하게 조회합니다.
    - 실무에서는 실시간 재고 모니터링, 품절 상태 알림, 자동 보충 로직에서 반드시 활용됩니다.

---

- `toggleProductVisibility(product)`
  - **기능**: 상품의 사용자 노출 여부를 토글합니다.
  - 상품의 `isVisible` 플래그를 반전시키고 상태를 로그로 출력합니다.
  - 📌 **설계 의도**:
    - **단일 책임 원칙**을 준수하여, 상품의 노출 상태 조정만을 담당합니다.
    - 실무에서는 이벤트 종료, 품절 상품 숨김, 시즌 상품 관리 등에 빠르게 대응하기 위한 필수 기능입니다.

---

- `deleteProduct(product)`
  - **기능**: 상품을 시스템에서 완전히 삭제하고, 재고 정보도 제거합니다.
  1. `Product.catalog`에서 상품 제거.
  2. `stockData`에서도 재고 정보 제거 후 로그 출력.
  - 📌 **설계 의도**:
    - 불필요한 데이터를 시스템에서 제거해 일관성을 유지하고, 메모리 누수를 방지합니다.
    - 실무에서는 완전 삭제 외에도 **논리적 삭제(Soft Delete)** 를 도입하여, 추후 복구 가능성을 열어두는 것이 일반적입니다.

---

- `suspendCustomer(user)`
  - **기능**: 특정 고객 계정을 정지시켜 서비스 이용을 차단합니다.
  - 사용자의 `isSuspended` 값을 `true`로 설정하고 로그를 출력합니다.
  - 📌 **설계 의도**:
    - **권한 분리**로 인해, 일반 사용자는 다른 계정을 절대로 제어할 수 없습니다.
    - 실무에서는 악성 사용자 차단, 약관 위반 시 계정 정지 처리를 자동화된 워크플로우로 처리합니다.

---

- `reinstateCustomer(user)`
  - **기능**: 정지된 고객 계정을 복구하여 정상적인 서비스 이용을 가능하게 합니다.
  - 사용자의 `isSuspended` 값을 `false`로 변경하고 복구 로그 출력.
  - 📌 **설계 의도**:
    - 관리자의 권한으로 정지된 계정 상태를 쉽게 복구할 수 있도록 유연한 상태 제어를 제공합니다.
    - 실무에서는 CS 처리, 이용 정지 기간 만료 후 자동 복구, 분쟁 해결 후 복구 등의 업무에 사용됩니다.

---

📌 **실무 적용 사례 총정리**

- ✅ **네이버 스마트스토어**: 상품 관리, 재고 조정, 사용자 제재 및 복구 처리를 위해 관리자 전용 대시보드를 운영하며, 모든 작업 내역은 감사 로그로 기록됩니다.
- ✅ **쿠팡**: 상품 추가/삭제/숨김 처리 기능을 통해 빠른 프로모션 관리, 시즌 상품 관리, 재고 수급 조정 업무를 수행합니다. 관리자 권한은 세부적으로 구분되어 데이터 접근과 조작을 제어합니다.
- ✅ **기업 ERP 시스템**: 관리자 권한에 따라 상품 정보 관리, 인사 관리, 계정 관리 권한이 세분화되어 있으며, 모든 중요한 조작은 트랜잭션 로그와 함께 변경 이력을 보관합니다.

---

💡 **설계 의사결정 트레이드오프**

| 선택 사항                 | 장점                             | 단점                                            |
| ------------------------- | -------------------------------- | ----------------------------------------------- |
| 관리자 권한 집중화        | 데이터 일관성 유지, 보안 강화    | 과도한 의존으로 단일 장애점(SPOF) 발생 가능     |
| 직접 재고 조작 차단       | 재고 무결성 보장, 오류 방지      | 관리자 인터페이스 개발 필요, 유지보수 비용 증가 |
| 완전 삭제 (Hard Delete)   | 메모리 관리 용이, 데이터 일관성  | 복구 불가, 감사 추적 어려움                     |
| 논리적 삭제 (Soft Delete) | 데이터 복구 가능, 감사 기록 용이 | 데이터 증가로 성능 저하, 추가 관리 필요         |

📌 **보완 설계 제안**

- ✅ **RBAC(Role-Based Access Control)**: 관리자 권한을 슈퍼 관리자, 상품 관리자, 사용자 관리자 등으로 세분화해 보안성을 높이고, 각 역할별 작업 범위를 명확히 제한합니다.
- ✅ **Soft Delete 도입**: 상품과 사용자 데이터 삭제 시 `isDeleted` 플래그를 사용한 논리적 삭제 방식으로, 데이터 복구와 감사 기록 보관을 지원합니다.
- ✅ **감사 로그(Audit Log)**: 모든 관리자 조작 내역을 별도 로그 시스템에 저장하고, 관리자 작업 이력 관리 대시보드를 제공합니다.
- ✅ **트랜잭션 처리 강화**: 재고 변경, 상품 삭제 등의 작업은 DB 트랜잭션을 사용해 일관성을 보장하며, 실패 시 자동 롤백 기능을 추가합니다.

---

## ✅ [5. Product 클래스: 추상 클래스, 정적 관리, 정보 은닉]

```jsx
class Product {
    static catalog = [];
    static nextId = 1;

    constructor(name, price) { ... }
    deliver(toUser) { ... }
    static printCatalog() { ... }
    addReview(customer, rating, comment) { ... }
    getAverageRating() { ... }
}

```

---

### 📚 **적용된 OOP 전략**

- ✅ **추상 클래스 (Abstract Class)**: 공통 속성과 인터페이스 제공, 직접 인스턴스화 방지
- ✅ **정적 멤버 (Static Members)**: 전체 상품에 공통적으로 적용되는 정보와 동작 관리
- ✅ **캡슐화 (Encapsulation)**: 민감한 속성 및 재고 관리 정보 은닉
- ✅ **다형성 (Polymorphism)**: `deliver` 메서드를 통해 다양한 상품 유형에 맞는 배송 로직 구현

---

### 🔍 **내부 동작 상세 설명**

- `constructor(name, price)`
  - **기능**: 상품 생성 시, 공통 속성(name, price) 설정과 고유 식별자 부여
  1. `new.target`으로 추상 클래스 직접 인스턴스화 방지
  2. 상품명과 가격을 인스턴스에 저장
  3. `INTERNAL_ID` 심볼로 고유 ID 부여, `Product.nextId` 증가
  4. 상품 노출 상태(`isVisible`) 기본값 `true`, 리뷰 배열 초기화
  - 📌 **설계 의도**:
    - 추상 클래스를 통해 **일관된 인터페이스 제공**과 **잘못된 객체 생성 방지**로 코드 안전성 확보
    - 고유 식별자는 심볼을 사용해 외부 노출 차단, **데이터 무결성 보장**

---

- `deliver(toUser)`
  - **기능**: 상품 배송 처리를 위한 추상 메서드. 자식 클래스에서 반드시 구현해야 함
  - 구현하지 않을 경우, 호출 시 에러 발생 → 개발자에게 구현 강제
  - 📌 **설계 의도**:
    - **다형성**을 활용해, 상품 유형에 따라 각기 다른 배송 방식을 구현하도록 강제
    - 실무에서는 물류 창고 연동, 택배사 API 호출, 디지털 컨텐츠 전송, 구독형 서비스 자동화 등 다양한 케이스로 확장

---

- `static printCatalog()`
  - **기능**: 현재 시스템에 등록된 전체 상품 목록을 출력하는 정적 메서드
  1. `Product.catalog` 배열 순회, 상품명, 가격, 재고, 노출 상태 출력
  2. `stockData`에서 재고 조회, `isVisible`로 노출 여부 확인
  - 📌 **설계 의도**:
    - **정적 메서드**로 전역적인 상품 정보에 접근 가능, 인스턴스 생성 없이도 호출
    - 실무에서는 관리자 페이지의 상품 목록, 재고 보고서 출력, API 응답 데이터 처리 등에서 그대로 활용됨

---

- `addReview(customer, rating, comment)`
  - **기능**: 상품에 대한 고객 리뷰 추가
  1. 리뷰 배열에 `{ user, rating, comment }` 형태로 저장
  2. 리뷰 작성 완료 로그 출력
  - 📌 **설계 의도**:
    - 상품 객체가 자체적으로 리뷰를 관리, **캡슐화**와 **책임 분리** 실현
    - 실무에서는 사용자 후기 관리, 리뷰 기반 추천 시스템, 평점 필터링 등에 활용

---

- `getAverageRating()`
  - **기능**: 상품의 평균 평점 계산
  1. 리뷰가 없으면 0 반환
  2. 리뷰가 존재하면 평점 총합을 계산해 평균 반환
  - 📌 **설계 의도**:
    - 상품 객체가 스스로 상태를 관리하며, 별도의 외부 계산 모듈 없이 필요한 정보를 제공
    - 실무에서는 상품 정렬, 추천 상품 선정, 인기 상품 필터링 등 마케팅 전략에 적극 활용

---

📌 **실무 적용 사례 총정리**

- ✅ **네이버 쇼핑, 쿠팡, 11번가** 등 주요 이커머스 플랫폼에서 상품 관리 시스템으로 유사한 구조를 사용
- ✅ 물리적 상품, 디지털 컨텐츠, 구독형 서비스 등 다양한 상품 유형이 공존하는 복잡한 환경에서도 **확장성과 유지보수성**을 확보

---

💡 **설계 의사결정 트레이드오프**

| 선택 사항           | 장점                               | 단점                          |
| ------------------- | ---------------------------------- | ----------------------------- |
| 정적 멤버 사용      | 전역 관리, 일관성 유지             | 테스트, 확장성 한계           |
| 추상 메서드 도입    | 자식 클래스 구현 강제, 코드 일관성 | 구현 누락 시 런타임 에러 발생 |
| 심볼로 고유 ID 관리 | 외부 노출 차단, 보안 강화          | 디버깅 어려움, 조회 불편      |

---

📌 **보완 설계 제안**

- ✅ **상품 상태 관리 고도화**: 노출 상태 외에도 `isDiscounted`, `isLimitedEdition` 등의 상태 관리 플래그 추가
- ✅ **리뷰 검증 로직 추가**: 부적절한 리뷰, 악성 리뷰 차단을 위한 검증 시스템 도입
- ✅ **정적 메서드 분리**: `ProductManager` 별도 클래스로 관리 책임 분산, SRP 준수

---

## ✅ [6. PhysicalProduct 클래스: 실물 상품 전용 배송 로직]

```jsx
class PhysicalProduct extends Product {
    constructor(name, price, weight) { ... }
    deliver(toUser) { ... }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **상속 (Inheritance)**: `Product` 추상 클래스의 공통 속성과 메서드를 상속받아 코드 중복 방지 및 일관성 유지
- ✅ **다형성 (Polymorphism)**: `deliver` 메서드를 상황에 맞게 구현, 실물 상품에 맞는 배송 방식 제공
- ✅ **캡슐화 (Encapsulation)**: 상품의 추가 속성(`weight`)과 동작을 객체 내부에서 안전하게 관리

---

### 🔍 **내부 동작 상세 설명**

- `constructor(name, price, weight)`
  - **메서드 기능**: 실물 상품 객체를 생성하고, 고유한 무게 정보를 추가하는 기능
  1. 부모 클래스인 `Product`의 생성자를 호출해 공통 속성 `name`과 `price`를 초기화
  2. 실물 상품 고유 속성인 `weight`(상품 무게)를 개별 인스턴스에 저장
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 실물 상품의 물류 처리와 배송비 계산에 필수적인 **무게 정보를 객체에 명시적으로 포함**
    - 실무에서는 이 무게 정보가 택배사 API에 전달되어 자동 배송비 계산, 물류 창고 최적화, 운송 수단 결정 등에 활용됨
    - 예) 상품 무게에 따라 드론 배송, 퀵서비스, 택배 선택 자동화

---

- `deliver(toUser)`
  - **메서드 기능**: 실물 상품을 고객에게 물리적으로 배송하는 과정을 처리
  - 주문 고객 정보를 받아, 상품명과 무게 정보를 포함해 "택배 배송" 로그 출력
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - **다형성**을 활용하여 `Order` 클래스에서는 일괄적으로 `Product` 타입으로 처리하더라도, 구체적인 배송 방법은 상품 유형에 따라 자동으로 결정
    - 실무에서는 이 메서드를 확장해 택배사 API 호출, 송장 출력, 물류 배차 시스템과 직접 연동
    - 예) CJ대한통운, 한진택배, 로젠택배 등과 실시간 배송 연동, 배송 상태 추적 구현

확장 예시:

```jsx
deliver(toUser) {
    // 물류 시스템 연동 예시 (실제 시스템에서는 API 호출)
    console.log(`📦 "${this.name}" 상품이 ${toUser.name}님께 택배로 배송됩니다. (무게: ${this.weight}kg)`);
    // 물류 시스템 호출: LogisticsAPI.createShipment(this, toUser);
}
```

---

📌 **실무 적용 사례 총정리**

- ✅ 쿠팡, G마켓, 11번가, 롯데온 같은 대형 이커머스 플랫폼에서 **실물 상품 배송 처리 로직**으로 동일한 구조 활용
- ✅ 다양한 배송 옵션(당일 배송, 새벽 배송, 일반 배송, 해외 배송)에 맞춰 `deliver` 메서드를 오버라이드하여, 배송 전략 패턴과 쉽게 결합 가능
- ✅ 실무에서는 물류 자동화, 배송 상태 추적, 송장 자동 발급, 반품 처리 시스템과도 연계되어 높은 확장성과 유연성을 제공

---

## ✅ [7. DigitalProduct 클래스: 디지털 상품 전용 배송 로직]

```jsx
class DigitalProduct extends Product {
    constructor(name, price, fileSize) { ... }
    deliver(toUser) { ... }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **상속 (Inheritance)**: `Product` 추상 클래스로부터 공통 속성과 메서드를 상속받아, 디지털 상품에 특화된 기능만 추가
- ✅ **다형성 (Polymorphism)**: `deliver` 메서드를 디지털 상품에 맞는 전송 방식으로 재정의
- ✅ **캡슐화 (Encapsulation)**: 파일 크기와 같은 디지털 상품 전용 정보를 객체 내부에 안전하게 관리

---

### 🔍 **내부 동작 상세 설명**

- `constructor(name, price, fileSize)`
  - **메서드 기능**: 디지털 상품 객체를 생성하고, 고유한 파일 크기 정보를 추가하는 기능
  1. 부모 클래스인 `Product`의 생성자를 호출하여 공통 속성인 `name`과 `price`를 초기화
  2. 디지털 상품 고유 속성인 `fileSize`(파일 크기, MB 단위)를 개별 인스턴스에 저장
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 파일 크기 정보는 다운로드 시간 안내, 네트워크 트래픽 관리, 사용자의 저장 공간 관리 등에 직접 활용됩니다.
    - 실무에서는 CDN(콘텐츠 전송 네트워크) 최적화, 서버 용량 관리, 다운로드 속도 제한, DRM(디지털 저작권 관리) 처리 등에 필요
    - 예)
      - 리디북스: eBook 파일 크기 표기 및 다운로드 용량 제한
      - 멜론, 스포티파이: 음원 파일 크기 관리 및 오프라인 저장 공간 계산
      - 넷플릭스: 영상 화질에 따른 예상 다운로드 용량 제공

---

- `deliver(toUser)`
  - **메서드 기능**: 디지털 상품을 구매자에게 즉시 전달하는 기능
  - 주문 고객 정보를 받아, 다운로드 링크 발급 또는 이메일 전송 방식을 통해 상품 제공
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - **다형성**을 통해 `Order` 클래스에서는 모든 상품을 동일하게 처리하더라도, 구체적인 전송 방식은 디지털 상품에 맞춰 독립적으로 정의
    - 실무 확장 사례:
      - 이메일 발송 API(SendGrid, Amazon SES, Mailgun) 연동
      - 다운로드 링크 자동 생성 및 1회 사용 제한
      - DRM 적용을 통한 보안 다운로드 처리

예시 코드 확장:

```jsx
deliver(toUser) {
    console.log(`📧 "${this.name}" 다운로드 링크가 ${toUser.name}님께 이메일로 발송되었습니다. (파일 크기: ${this.fileSize}MB)`);
    // 실무: EmailService.sendDownloadLink(toUser.email, this.generateSecureLink());
}
```

---

📌 **실무 적용 사례 총정리**

- ✅ 리디북스, 네이버 시리즈, 멜론, 스포티파이, 넷플릭스 등 디지털 콘텐츠 제공 플랫폼에서 **동일한 구조로 구현**
- ✅ 다운로드 링크 제공, 콘텐츠 스트리밍, 구독형 서비스 제공 등에서 **유연하게 대응할 수 있도록 설계된 고급 패턴**
- ✅ 실무에서는 DRM 보호, 1회 다운로드 제한, 기간 제한 링크, 자동 만료 링크 발급 등의 고급 기능과 쉽게 연계

---

## ✅ [8. Order 클래스: 주문 처리, 상태 관리, 위임 패턴 적용]

```jsx
class Order {
    static nextOrderId = 1;

    constructor(customer, products) { ... }
    checkout(paymentMethod) { ... }
    cancel() { ... }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **정적 멤버 (Static Members)**: 전역 주문 번호 관리, 주문 인스턴스 고유 식별자 부여
- ✅ **조합 (Composition)**: 주문 객체가 고객과 상품 목록을 내부에 조합하여 보관
- ✅ **캡슐화 (Encapsulation)**: 주문 상태와 세부 정보는 외부에서 직접 접근하지 않고, 메서드를 통해 안전하게 관리
- ✅ **위임 (Delegation)**: 결제 처리와 상품 배송 책임을 각각 `PaymentMethod`, `Product`에 위임
- ✅ **다형성 (Polymorphism)**: 다양한 결제 수단과 상품 유형에 맞는 행동을 일관된 방식으로 처리

---

### 🔍 **내부 동작 상세 설명**

- `constructor(customer, products)`
  - **메서드 기능**: 새로운 주문 객체를 생성하고 주문 정보를 초기화
  1. 고유한 주문 ID를 부여 (`Order.nextOrderId` 증가)
  2. 주문 고객과 상품 목록을 내부에 저장
  3. 상품 가격을 합산해 총 결제 금액(`totalPrice`) 계산
  4. 주문 상태를 기본값 `pending`으로 설정
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 고유 주문 ID로 트랜잭션 추적과 장애 대응 시 원인 분석 가능
    - 주문 상태 관리를 통해 각 프로세스 흐름을 명확히 구분 (결제 전, 결제 완료, 취소 상태)
    - 실무에서는 상태에 따라 주문 이력, CS 처리, 환불 가능 여부 등을 제어

---

- `checkout(paymentMethod)`
  - **메서드 기능**: 결제 수단을 이용해 주문 결제 및 상품 배송 처리
  1. 주문 상태가 `pending`인지 확인 (중복 결제 방지)
  2. `paymentMethod.processPayment` 호출로 결제 처리 (**위임 패턴 적용**)
  3. 결제 성공 시, 상품 목록 순회하며 각 상품의 `deliver` 호출 (**다형성 적용**)
  4. 물리적 상품은 재고 차감 처리
  5. 주문 상태를 `completed`로 변경하고 성공 메시지 출력
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - \*위임(Delegation)\*\*을 통해 결제 처리, 배송 책임 분산 → `Order`는 복잡한 로직을 몰라도 동작
    - 새로운 결제 수단 추가 시, `PaymentMethod` 인터페이스 구현만으로 확장 (**OCP 원칙 준수**)
    - 실무에서는 PG사 연동 (토스페이먼츠, 카카오페이, 네이버페이), 결제 실패/재시도 처리, 자동 환불 시스템과도 연계

---

- `cancel()`
  - **메서드 기능**: 주문 상태가 `pending`일 때만 주문 취소 가능
  1. 현재 상태가 `pending`인지 검사
  2. `pending`일 경우 상태를 `cancelled`로 변경, 취소 완료 메시지 출력
  3. 이미 `completed` 상태면 취소 불가 메시지 출력
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - **상태 패턴(State Pattern)** 활용 → 상태에 따른 유효한 행동만 수행
    - 실무에서는 결제 전 취소는 즉시 처리, 결제 후 취소는 환불 정책 적용
    - 취소 시 자동 환불, 재고 복구, 포인트 회수 등 부가 로직과 쉽게 연동

---

📌 **실무 적용 사례 총정리**

- ✅ 쿠팡, 네이버 스마트스토어, 이마트몰 등 대형 이커머스 플랫폼에서 동일한 주문 처리 패턴 적용
- ✅ 상태 기반 주문 처리 → 결제 실패, 배송 실패, 취소 요청 등에 빠르게 대응
- ✅ 트랜잭션 관리, 주문 이력 추적, 자동 알림 시스템(SMS, 이메일), 고객 CS 대응에 필수적인 설계
- ✅ 확장성 높은 구조 덕분에, 정기 결제, 구독 서비스, 선물하기 기능 등 다양한 비즈니스 모델에도 쉽게 적용

---

## ✅ [9. PaymentMethod 클래스: 결제 인터페이스 제공]

```jsx
class PaymentMethod {
  processPayment(amount) {
    throw new Error("processPayment()는 반드시 구현해야 합니다.");
  }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **추상 클래스 (Abstract Class)**: 공통된 결제 인터페이스 제공, 직접 인스턴스화 방지
- ✅ **다형성 (Polymorphism)**: 다양한 결제 수단 클래스가 `processPayment` 메서드를 각기 다른 방식으로 구현

---

### 🔍 **내부 동작 상세 설명**

- `processPayment(amount)`
  - **메서드 기능**:
    - 결제 처리 인터페이스 역할을 담당하며, 반드시 자식 클래스에서 구현해야 하는 추상 메서드입니다.
    - 이 메서드는 호출 시 구현되지 않았을 경우 에러를 발생시켜, 개발자가 반드시 결제 처리 로직을 정의하도록 강제합니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - \*다형성(Polymorphism)\*\*을 활용해, `Order` 클래스나 호출자는 결제 수단의 세부 구현을 알 필요 없이 `processPayment`만 호출하면 됩니다.
    - 실무에서는 카드 결제, 계좌 이체, 포인트 결제, 모바일 결제, 쿠폰 결제 등 다양한 결제 수단을 하나의 통일된 인터페이스로 관리합니다.
    - 각 결제 수단 클래스는 외부 결제 API 호출, 결제 실패/성공 처리, 로깅, 트랜잭션 관리 등을 독립적으로 구현할 수 있어 유지보수성과 확장성이 극대화됩니다.

---

### 📌 **왜 이런 방식을 선택했는가?**

- 결제 수단은 비즈니스 변화에 따라 계속 추가, 수정, 폐기될 수 있는 영역입니다.
- 추상 클래스와 강제 인터페이스 설계를 통해, **결제 처리 로직을 표준화**하고, 개발자 실수로 인한 미구현 방지와 결제 처리 오류를 방지합니다.
- 새로운 결제 방식 추가 시, 기존 `Order`나 다른 로직을 수정할 필요 없이 새로운 결제 클래스만 구현하면 되므로, **OCP(개방-폐쇄 원칙)** 을 완벽하게 충족합니다.
- 예) PayPal, Stripe, Toss Payments, 네이버페이, 카카오페이, 포인트 결제, 상품권 등 추가 시 기존 코드는 그대로 유지하고, 새로운 클래스만 추가합니다.

---

### 📖 **클래스 주요 역할**

- 모든 결제 수단 클래스의 **공통 부모 클래스** 역할 수행
- 반드시 `processPayment` 메서드를 구현하도록 강제해, 다양한 결제 수단에서도 **일관된 호출 인터페이스** 제공
- 결제 로직의 복잡도와 변화에도 불구하고, **주문 처리 시스템과 결제 로직을 완전히 분리**

---

📌 **실무 적용 사례 총정리**

- ✅ 모든 이커머스 플랫폼(쿠팡, G마켓, 11번가, 네이버 스마트스토어)과 결제 서비스 프로바이더(PG사)에서 필수적으로 사용하는 설계 패턴
- ✅ 신용카드, 간편 결제(네이버페이, 카카오페이), 토스페이, 삼성페이, 계좌 이체, 포인트, 상품권 등 다양한 결제 방식 처리 시 공통 인터페이스로 활용
- ✅ 결제 수단 로직 변경 시에도 주문 로직과 완전히 분리되어 시스템 안정성 보장
- ✅ 결제 실패 처리, 재시도 로직, 외부 결제 API 호출 실패 대비, 트랜잭션 롤백 관리, 감사 로그 기록 등의 세부 처리도 각 결제 클래스에서 독립적으로 관리 가능

---

## ✅ [10. CreditCardPayment & PayPalPayment 클래스: 결제 전략 구현]

```jsx
class CreditCardPayment extends PaymentMethod {
  processPayment(amount) {
    console.log(`💳 신용카드로 ${amount}원 결제가 처리되었습니다.`);
    // 📌 실무 확장 예시: 신용카드 API 호출, 트랜잭션 처리, 결제 성공/실패 로그 기록
    // 예: KG이니시스, 토스페이먼츠, 네이버페이 등 API 연동
  }
}

class PayPalPayment extends PaymentMethod {
  processPayment(amount) {
    console.log(`💰 PayPal로 ${amount}원 결제가 처리되었습니다.`);
    // 📌 실무 확장 예시: PayPal API 호출, 통화 환전, 결제 보안 검증, 결제 상태 확인
    // 예: 해외 결제, 글로벌 디지털 콘텐츠 판매 등 적용
  }
}
```

---

### 📚 **적용된 OOP 전략**

- ✅ **상속 (Inheritance)**: `PaymentMethod` 추상 클래스로부터 공통 결제 인터페이스 구현
- ✅ **전략 패턴 (Strategy Pattern)**: 결제 수단에 따라 결제 방식을 동적으로 결정
- ✅ **다형성 (Polymorphism)**: `processPayment` 메서드를 결제 수단별로 서로 다른 방식으로 구현

---

### 🔍 **내부 동작 상세 설명**

- `CreditCardPayment.processPayment(amount)`
  - **메서드 기능**:
    - 주어진 금액을 신용카드로 결제하는 로직을 담당합니다.
    - 현재는 간단한 콘솔 출력으로 처리하지만, 실무에서는 실제 결제 게이트웨이 API 호출, 트랜잭션 관리, 결제 성공/실패 처리, 감사 로그 기록 등을 이 메서드 내에 구현합니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 실무에서 흔히 사용하는 **결제 게이트웨이(Gateway) API**와의 통신은 이 위치에 구현됩니다.
    - 예) KG이니시스, 토스페이먼츠, 네이버페이, 삼성페이 등의 카드 결제 API 연동
    - **다형성** 덕분에 `Order` 클래스는 어떤 결제 수단을 사용하는지 몰라도, 일관된 `processPayment` 호출로 처리할 수 있습니다.
    - 결제 실패, 인증 실패, 한도 초과 등의 복잡한 예외 처리도 이곳에 확장할 수 있습니다.

---

- `PayPalPayment.processPayment(amount)`
  - **메서드 기능**:
    - 주어진 금액을 PayPal로 결제하는 로직을 처리합니다.
    - 간단한 로그 출력 외에도, 실무에서는 PayPal API 호출, 통화 환전, 결제 보안 검증, 트랜잭션 관리 등이 포함됩니다.
  - 📌 **설계 의도 및 OOP 적용 효과**:
    - 해외 결제 처리를 위한 대표적인 수단으로, 결제 보안, 다국적 통화 처리, 환전, 세금 계산 등의 복잡한 로직이 포함됩니다.
    - \*OCP(개방-폐쇄 원칙)\*\*을 충실히 적용해, PayPal과 같은 해외 결제 수단 추가 시에도 기존 `Order` 로직은 그대로 유지되고, 새 클래스만 추가하면 됩니다.
    - 글로벌 쇼핑몰, 해외 디지털 콘텐츠 판매 사이트(예: Steam, Amazon, eBay 등)에서 필수로 적용하는 패턴입니다.

---

📌 **왜 이런 방식을 선택했는가?**

- 결제 수단은 비즈니스와 기술 환경에 따라 지속적으로 추가, 변경, 폐기됩니다.
- \*전략 패턴(Strategy Pattern)\*\*을 사용해 결제 로직을 독립적인 객체로 분리하면, 실행 시점에 결제 수단을 유연하게 교체할 수 있습니다.
- 새로운 결제 방식 추가 시 기존 코드를 전혀 수정하지 않고, 새로운 클래스를 추가하는 것만으로 기능 확장이 가능합니다.
- 유지보수성과 테스트 용이성을 높이며, 마케팅 이벤트용 특별 결제 수단(예: 쿠폰 전용 결제, 포인트 전용 결제)도 손쉽게 추가할 수 있습니다.

---

📖 **클래스 주요 역할**

- `CreditCardPayment`: 신용카드 기반 결제 로직을 담당하며, 실무에서는 카드사 API 호출, 인증 처리, 결제 성공/실패 처리, 감사 로그 기록 등을 담당합니다.
- `PayPalPayment`: 해외 및 온라인 결제용으로, PayPal API 호출, 통화 환전, 세금 계산, 국제 거래 보안 검증 등을 담당합니다.

---

📌 **실무 적용 사례 총정리**

- ✅ 네이버페이, 카카오페이, 페이코, 삼성페이, 토스, Visa, MasterCard, PayPal 등 다양한 결제 수단 처리를 위한 대표적 설계 패턴
- ✅ 마케팅 전용 결제 수단(예: 포인트, 쿠폰), 구독 서비스 결제, 할부 결제 등 다양한 비즈니스 모델 확장에 즉각 대응
- ✅ 대규모 커머스 시스템에서 필수적인 설계로, 결제 처리 로직과 주문 시스템을 철저히 분리해 시스템 안정성 확보
- ✅ 결제 로직 복잡화에도 안정적인 유지보수 가능, 새로운 국가 진출 시 해외 결제 수단 추가 대응 용이

---

## ✅ [11. 시나리오 테스트 & 통합 테스트: 전체 시스템 동작 검증]

**적용된 OOP 전략**:

- ✅ **모듈화 (Modularity)**:
  각 클래스는 명확한 책임과 역할을 가지며, 독립적으로 설계되었습니다. 이로 인해 단위 테스트가 용이하고, 기능 변경이나 확장 시 다른 모듈에 영향을 주지 않고 안전하게 관리할 수 있습니다. 실무에서는 CI/CD 환경에서 자동화 테스트와 빠른 배포를 가능하게 만드는 필수 설계 요소입니다.
- ✅ **다형성 (Polymorphism)**:
  다양한 상품 유형과 결제 수단에 대해 공통된 인터페이스로 일관된 동작 검증이 가능합니다. 새로운 기능 추가 시 기존 코드를 수정하지 않고 객체 교체만으로 테스트와 로직 검증이 가능하므로, 유지보수성과 확장성이 크게 향상됩니다. 실무에서는 다양한 결제 API, 상품 배송 로직을 효율적으로 관리할 때 반드시 필요한 설계 전략입니다.
- ✅ **위임 (Delegation)**:
  주문 처리 시, 결제와 배송 책임을 각각 `PaymentMethod`, `Product` 객체에 위임하여, 주문 로직은 핵심 흐름에만 집중하고 세부 처리는 각 객체가 담당하도록 설계했습니다. 이를 통해 전략 패턴과 위임 패턴을 효과적으로 활용하며, 테스트 환경에서도 필요한 전략 객체를 유연하게 주입해 다양한 시나리오를 검증할 수 있습니다.
- ✅ **단일 책임 원칙 (SRP)**:
  각 테스트 시나리오는 하나의 책임과 목적에 집중하도록 분리되어 작성되었습니다. 이를 통해 테스트 코드의 가독성과 유지보수성이 높아지고, 특정 로직이 변경되더라도 관련 테스트만 수정하면 되도록 설계되었습니다. 실무에서는 코드 리팩토링, 대규모 기능 추가 시 안정적인 품질 보장을 위해 반드시 준수해야 하는 원칙입니다.

---

### 📌 **[1] 관리자 상품 등록 및 재고 관리 테스트**

```jsx
const adminAlice = new Admin("Alice", "admin123");
const product1 = new PhysicalProduct("Laptop", 1500, 2.5);
const product2 = new DigitalProduct("E-Book", 30, 150);

adminAlice.addProduct(product1, 5);
adminAlice.addProduct(product2, 100);
Product.printCatalog();
```

- **설계 의도**:
  - 상품 등록과 초기 재고 설정, 카탈로그 출력 기능 정상 동작 검증.
- **실무적 활용**:
  - 관리자가 대량의 상품을 등록하고, 재고 상태를 빠르게 확인할 때 사용.

---

### 📌 **[2] 고객 장바구니 담기 및 주문 생성 테스트**

```jsx
const customerBob = new Customer("Bob", "pass1234");
customerBob.addToCart(product1);
customerBob.addToCart(product2);
const orderByBob = customerBob.createOrder();
```

- **설계 의도**:
  - 고객의 장바구니 관리 및 주문 생성 프로세스 정상 동작 검증.
- **실무적 활용**:
  - 고객의 구매 흐름, 장바구니 보관 기간, 상품 품절 처리 시 행동 확인.

---

### 📌 **[3] 주문 결제 및 배송 처리 테스트 (신용카드 결제)**

```jsx
if (orderByBob) {
  orderByBob.checkout(new CreditCardPayment());
}
```

- **설계 의도**:
  - 신용카드 결제 프로세스와 배송 처리 로직 검증.
- **실무적 활용**:
  - 다양한 결제 수단이 올바르게 처리되고, 결제 후 재고 차감 및 배송 절차가 올바르게 실행되는지 확인.

---

### 📌 **[4] 관리자 재고 확인 및 재고 보충 테스트**

```jsx
console.log(
  `Remaining stock of Laptop: ${adminAlice.checkStock(product1)} units`
);
adminAlice.changeStock(product1, 10);
adminAlice.changeStock(product2, 120);
Product.printCatalog();
```

- **설계 의도**:
  - 재고 확인, 재고 보충, 카탈로그 업데이트 동작 검증.
- **실무적 활용**:
  - 품절 상태 관리, 재고 경고 알림, 자동 재고 보충 로직 구현 시 유용.

---

### 📌 **[5] 주문 취소 테스트 (성공/실패 케이스)**

```jsx
if (orderByBob) {
  orderByBob.cancel(); // 실패: 이미 결제 완료된 주문
}

customerBob.addToCart(product1);
const orderByBob2 = customerBob.createOrder();
if (orderByBob2) {
  orderByBob2.cancel(); // 성공: 결제 전 취소
}
```

- **설계 의도**:
  - 주문 상태에 따른 취소 가능 여부 검증.
- **실무적 활용**:
  - CS 대응, 자동 환불, 주문 변경 로직 구현 시 필수 검증.

---

### 📌 **[6] 상품 리뷰 작성 및 평점 확인 테스트**

```java
customerBob.reviewProduct(product1, 5, "Excellent quality!");
console.log(`Average rating of ${product1.name}: ${product1.getAverageRating().toFixed(1)} stars`);
```

- **설계 의도**:
  - 리뷰 작성 및 평균 평점 계산 로직 검증.
- **실무적 활용**:
  - 고객 리뷰 반영, 인기 상품 선정, 추천 시스템에 활용.

---

### 📌 **[7] 관리자 상품 숨김/삭제 테스트**

```jsx
adminAlice.toggleProductVisibility(product2);
Product.printCatalog();

adminAlice.deleteProduct(product2);
Product.printCatalog();
```

- **설계 의도**:
  - 상품 숨김 처리 및 완전 삭제 기능 검증.
- **실무적 활용**:
  - 마케팅 프로모션 상품 관리, 시즌 상품 관리, 품절 상품 비활성화에 사용.

---

### 📌 **[8] 사용자 계정 정지/복구 테스트**

```jsx
adminAlice.suspendCustomer(customerBob);
customerBob.login("pass1234"); // 실패: 정지 상태

adminAlice.reinstateCustomer(customerBob);
customerBob.login("pass1234"); // 성공: 복구됨
```

- **설계 의도**:
  - 계정 상태 관리(정지/복구) 기능 검증.
- **실무적 활용**:
  - 악성 사용자 차단, 이벤트 한정 계정 관리, 이용 약관 위반 대응.

---

### 📌 **[9] PayPal 결제 방식 테스트 (다형성 검증)**

```jsx
customerBob.addToCart(product1);
const orderByBob3 = customerBob.createOrder();
if (orderByBob3) {
  orderByBob3.checkout(new PayPalPayment());
}
```

- **설계 의도**:
  - PayPal 결제 방식이 기존 로직과 문제없이 동작하는지 검증.
- **실무적 활용**:
  - 해외 판매, 다양한 결제 수단 지원을 위한 다형성 검증.

---

## 📌 **[시스템 전체 동작 흐름 시각화]**

---

```plaintxt
+----------------+      +----------------+      +------------------+      +-----------------+
|    Customer    |      |     Admin      |      |     Product      |      |      Order      |
+----------------+      +----------------+      +------------------+      +-----------------+
        |                       |                        |                        |
        | 1️⃣ 상품 조회 요청     |                        |                        |
        |---------------------->|                        |                        |
        |                       |                        |                        |
        | 2️⃣ 상품 목록 확인      |                        |                        |
        |<----------------------|                        |                        |
        |                       |                        |                        |
        | 3️⃣ 장바구니에 담기    |                        |                        |
        |---------------------->|                        |                        |
        |                       |   4️⃣ 재고 확인 (WeakMap) |                        |
        |                       |----------------------->|                        |
        |                       |<-----------------------|                        |
        |                       |                        |                        |
        | 5️⃣ 주문 생성         |                        |                        |
        |---------------------->|                        |                        |
        |                       |                        |                        |
        | 6️⃣ 결제 (Strategy)    |                        |                        |
        |---------------------->|                        |                        |
        |                       |                        |                        |
        |   [PaymentMethod.processPayment()]             |                        |
        |                       |                        |                        |
        | 7️⃣ 주문 상태 업데이트 |                        |                        |
        |---------------------->|                        |                        |
        |                       | 8️⃣ 배송 요청 (Polymorphism)                      |
        |                       |----------------------->|                        |
        |                       |                        | 9️⃣ deliver() 호출     |
        |                       |                        |---------------------->|
        |                       |                        |<-----------------------|
        |                       |                        |                        |
        |  🔄 주문 완료 상태 변경  |                        |                        |
        |---------------------->|                        |                        |
        |                       |                        |                        |
        |  🔔 알림 발송 (옵션)    |                        |                        |
        |                       |                        |                        |
        |  📚 주문 내역 확인     |                        |                        |
        |<----------------------|                        |                        |

+----------------+      +----------------+      +------------------+      +-----------------+
|     Admin      |                      [관리자(Admin) 섹션]                           |
+----------------+
        |  🛠️ 상품 등록/수정     |                        |                        |
        |---------------------->|   🗃️ WeakMap 재고 관리   |                        |
        |                       |----------------------->|                        |
        |                       |                        |                        |
        |  📦 재고 변경          |                        |                        |
        |---------------------->|                        |                        |
        |                       |                        |                        |
        |  🗑️ 상품 숨김/삭제     |                        |                        |
        |---------------------->|                        |                        |

[주문 실패 시]

        |                       |                        |                        |
        |   🚫 결제 실패 처리    |                        |                        |
        |---------------------->|                        |                        |
        |   ♻️ 재시도 또는 취소  |                        |                        |
        |---------------------->|                        |                        |
```

---

### 📖 **설명**

- **1~2단계:** 고객은 상품을 조회하고, 장바구니에 담습니다.
- **3~6단계:** 주문을 생성하고 결제를 진행합니다. (전략 패턴 사용)
- **7~9단계:** 주문 완료 후 상품 배송이 실행됩니다. (다형성으로 상품 유형에 따라 다른 배송 방식)
- **관리자(Admin):** 상품 등록, 재고 관리, 상품 노출 관리, 사용자 계정 관리 등을 수행합니다.
- **예외 처리:** 결제 실패 시 재시도 또는 취소 로직이 작동합니다.

---

# ⚠️ 최종 보완 파트: 예외 시나리오 & 운영 기능 강화

---

## 1. 📦 재고 부족 처리 강화

**🎯 목표**

- 주문 시점에 실시간 재고를 정확히 검증하고, **주문 실패**, **부분 주문**, **자동 재고 보충 알림** 등 다양한 대응을 지원합니다.

**💡 실제 상황 예시**

- 블랙프라이데이 기간 인기 노트북이 갑자기 매진되어 다수 고객이 결제 단계에서 주문이 취소되는 경우
- 고객 A가 헤드폰을 장바구니에 담아두고 결제하려 할 때, 운영팀이 재고를 수동으로 업데이트하지 않아 구매가 불가한 경우

**❓ 왜 필요한지**

- 재고 소진을 사전에 인지하지 못하면 고객 불만과 CS 폭주로 이어집니다.
- 자동화된 검증과 알림을 통해 **매출 손실**을 최소화하고 **운영 효율**을 높여야 합니다.

```jsx
class Order {
  // … 기존 멤버 생략 …

  checkout(paymentMethod) {
    if (this.status !== "pending") return;

    // ① 재고 불충분 항목 선별
    const outOfStock = this.products.filter(
      (p) => (stockData.get(p) || 0) <= 0
    );
    if (outOfStock.length) {
      console.log(
        `🚫 주문 ${this.id} 실패: 다음 상품 재고 부족 → ` +
          outOfStock.map((p) => `"${p.name}"`).join(", ")
      );
      this.status = "failed";
      // Optional: 재고 보충 요청 이벤트 발행
      // eventBus.publish("stockLow", { products: outOfStock, orderId: this.id });
      return;
    }

    // ② 결제 및 배송 처리 (정상 흐름)
    try {
      paymentMethod.processPayment(this.totalPrice);
      this.products.forEach((p) => {
        p.deliver(this.customer);
        stockData.set(p, stockData.get(p) - 1);
      });
      this.status = "completed";
      console.log(`✅ 주문 ${this.id} 완료: 총액 ${this.totalPrice}원`);
    } catch (err) {
      this.status = "failed";
      console.log(`🚫 주문 ${this.id} 실패: ${err.message}`);
    }
  }
}
```

**🔍 예상 결과**

```
🚫 주문 42 실패: 다음 상품 재고 부족 → "Laptop", "Headphones"
```

- **✅ 보완 포인트**
  - **부분 주문 처리**: 필수 상품만 분리 발송하려면 `pendingItems`/`shippedItems` 구분
  - **자동 보충 알림**: 재고 임계치 이하 시 관리자 알림
  - **트랜잭션 관리**: DB 트랜잭션 또는 분산 트랜잭션 사용

---

## 2. 💳 결제 실패 처리 강화

**🎯 목표**

- 다양한 결제 오류(한도 초과, 네트워크 타임아웃, 인증 실패 등)를 **분류**, **로깅**, **재시도** 가능한 구조로 만들고, 운영 대시보드에 통계 데이터를 남깁니다.

**💡 실제 상황 예시**

- 주말 프로모션 중 PG사 서버 과부하로 일부 고객 결제가 네트워크 오류로 실패할 때
- 고객 B가 보유 포인트로 결제하려다 포인트 부족 오류가 발생한 경우

**❓ 왜 필요한지**

- “결제 실패” 메시지만 표시되면 고객 혼란과 CS 증가
- 네트워크 오류 등은 재시도를 통해 매출을 회복할 수 있으므로, **자동 재시도** 로직이 필수
- 오류 유형별 통계를 쌓아 PG사 변경, UX 개선, 자동 복구 근거로 활용

```jsx
class NetworkError extends Error {}
class InsufficientFundsError extends Error {}
class AuthenticationError extends Error {}

class RobustPayment extends PaymentMethod {
  processPayment(amount) {
    const rnd = Math.random();
    if (rnd < 0.2) throw new NetworkError("PG사 네트워크 연결 실패");
    if (rnd < 0.3) throw new InsufficientFundsError("잔액이 부족합니다");
    if (rnd < 0.35) throw new AuthenticationError("결제 인증 실패");
    console.log(`💳 ${amount}원 결제 성공`);
  }
}

class Order {
  // … 기존 멤버 생략 …

  checkout(paymentMethod) {
    if (this.status !== "pending") return;
    let attempts = 0,
      maxRetries = 3;

    while (attempts < maxRetries) {
      try {
        paymentMethod.processPayment(this.totalPrice);
        // 배송 로직…
        this.status = "completed";
        console.log(`✅ 주문 ${this.id} 완료: 총액 ${this.totalPrice}원`);
        return;
      } catch (err) {
        attempts++;
        console.log(
          `⚠️ 결제 시도 ${attempts}/${maxRetries} 실패: ${err.message}`
        );

        if (err instanceof NetworkError && attempts < maxRetries) {
          continue;
        }

        this.status = "failed";
        console.log(
          `🚫 주문 ${this.id} 실패: ${err.message} ` +
            `(수단: ${paymentMethod.constructor.name})`
        );
        // Optional: APM 전송
        // Monitoring.capture(err, { orderId: this.id, paymentMethod: paymentMethod.constructor.name });
        return;
      }
    }
  }
}
```

**🔍 예상 결과**

```
⚠️ 결제 시도 1/3 실패: PG사 네트워크 연결 실패
⚠️ 결제 시도 2/3 실패: PG사 네트워크 연결 실패
💳 1800원 결제 성공
✅ 주문 43 완료: 총액 1800원

```

- **✅ 보완 포인트**
  - **아이덴포텐시 Key** 사용으로 중복 결제 방지
  - **서킷 브레이커** 적용으로 PG사 과부하 방지
  - **사용자 안내**: 프론트엔드에 재시도 안내 메시지 제공

---

## 3. 🔐 권한 오류 처리 강화

**🎯 목표**

- **Service Layer**에서 호출 권한을 검증하고, **AuthorizationError** 로 명확히 구분한 후 안전하게 응답합니다.

**💡 실제 상황 예시**

- 고객 C가 개발자 도구를 이용해 관리자 전용 API(`/admin/change-stock`)를 직접 호출하려 할 때
- 내부 직원이 UI 권한 설정 오류로 상품 삭제를 시도했을 때

**❓ 왜 필요한지**

- 권한 검증 없이는 악의적 사용자가 API로 시스템을 조작할 수 있어 심각한 보안 사고로 이어집니다.
- 명확한 예외 처리와 HTTP 403 응답으로 **보안 컴플라이언스**를 준수하고, 침입 시도를 빠르게 탐지·차단할 수 있습니다.

```jsx
class AuthorizationError extends Error {
  constructor(action) {
    super(`권한 없음: ${action} 수행 불가`);
    this.name = "AuthorizationError";
  }
}

class AdminService {
  constructor(user) {
    this.user = user;
  }

  changeStock(product, qty) {
    if (!(this.user instanceof Admin)) {
      throw new AuthorizationError("changeStock");
    }
    stockData.set(product, qty);
  }
}

function changeStockController(req, res) {
  try {
    const svc = new AdminService(req.currentUser);
    svc.changeStock(req.body.product, req.body.qty);
    res.status(200).json({ message: "재고 수정 완료" });
  } catch (err) {
    if (err instanceof AuthorizationError) {
      res.status(403).json({ error: err.message });
    } else {
      res.status(500).json({ error: "서버 오류" });
    }
  }
}
```

**🔍 예상 결과**

- **콘솔**

  ```
  🚫 권한 오류: 권한 없음: changeStock 수행 불가

  ```

- **HTTP 응답**
  ```json
  {
    "status": 403,
    "error": "권한 없음: changeStock 수행 불가"
  }
  ```
- **✅ 보완 포인트**
  - **RBAC**(Role-Based Access Control): `user.roles.includes("STOCK_MANAGER")` 등 유연한 권한 체크
  - **감사 로그**: 거부된 요청도 별도 테이블에 기록하여 보안 감사에 활용
  - **API 문서화**: Swagger/OpenAPI로 권한 요구사항 명시

---

## 4. ♻️ 논리적 삭제(Soft Delete) 지원

**🎯 목표**

- 삭제된 데이터 이력을 보존하면서, 화면·API에서는 완전히 숨기고 즉시 **복구**할 수 있는 기능을 제공합니다.

**💡 실제 상황 예시**

- 블랙프라이데이 이벤트 상품을 일시적으로 숨겼다 이벤트 종료 후 복구해야 할 때
- 고객 리뷰, 주문 분석을 위해 삭제된 상품 로그를 남겨야 하는 경우

**❓ 왜 필요한지**

- 물리 삭제 시 참조 무결성 오류가 발생하고, 감사 로그 확보가 불가능합니다.
- Soft Delete를 사용하면 **데이터 보존**, **신속 복구**, **안정적 운영**이 가능합니다.

```jsx
// Product 클래스에 논리 삭제 플래그
class Product {
  static catalog = [];
  static nextId = 1;

  constructor(name, price) {
    if (new.target === Product) throw new Error("추상 클래스입니다.");
    this.name = name;
    this.price = price;
    this[INTERNAL_ID] = Product.nextId++;
    this.isVisible = true;
    this.reviews = [];
    this.isDeleted = false; // 논리 삭제 여부 초기화
  }

  static printCatalog() {
    console.log("\n📚 [현재 상품 카탈로그]");
    this.catalog
      .filter((p) => !p.isDeleted)
      .forEach((p) => {
        const stock = stockData.get(p) || 0;
        console.log(`- ${p.name} | ${p.price}원 | 재고: ${stock}`);
      });
  }
}

// Admin 클래스에 delete/restore 메서드
class Admin extends User {
  deleteProduct(product) {
    if (product.isDeleted) {
      console.log(`⚠️ "${product.name}"은 이미 삭제 상태입니다.`);
      return;
    }
    product.isDeleted = true;
    console.log(`🗑️ "${product.name}" 논리 삭제 처리되었습니다.`);
  }

  restoreProduct(product) {
    if (!product.isDeleted) {
      console.log(`⚠️ "${product.name}"은 삭제 상태가 아닙니다.`);
      return;
    }
    product.isDeleted = false;
    console.log(`♻️ "${product.name}" 복구되었습니다.`);
  }
}

// 운영 시나리오
adminAlice.deleteProduct(laptop); // 🗑️ "Laptop" 삭제
Product.printCatalog(); // "Laptop" 제외
adminAlice.restoreProduct(laptop); // ♻️ "Laptop" 복구
Product.printCatalog(); // 다시 노출
```

---

## 5. 📊 전체 주문 관리용 정적 멤버 추가

**🎯 목표**

- **운영 대시보드**, **배치 재시도**, **매출 분석** 등 운영·분석 용도로 모든 주문을 집계·조회할 수 있도록 지원합니다.

**💡 실제 상황 예시**

- 운영팀이 “실시간 pending 주문 수”를 확인해 재고 보충 시점을 판단할 때
- 실패(`failed`) 주문을 배치로 자동 재결제하거나 CS 팀에 알림을 보낼 때
- 일별·월별 매출 통계를 생성해 경영진 리포트에 활용할 때

**❓ 왜 필요한지**

- 단일 `Order` 인스턴스만 관리하면 실시간 트래킹이 불가능합니다.
- 모든 주문을 **메모리**나 **캐시**에 보관하면 운영 대시보드 및 자동화 작업이 쉬워집니다.

```jsx
class Order {
  static nextOrderId = 1;
  static allOrders = []; // 전체 주문 저장소

  constructor(customer, products) {
    this.id = Order.nextOrderId++;
    this.customer = customer;
    this.products = [...products];
    this.totalPrice = products.reduce((sum, p) => sum + p.price, 0);
    this.status = "pending";
    Order.allOrders.push(this); // 주문 생성 시 자동 등록
  }

  static getOrdersByStatus(status) {
    return this.allOrders.filter((o) => o.status === status);
  }

  static summary() {
    const summary = { pending: 0, completed: 0, failed: 0 };
    let totalRevenue = 0;
    this.allOrders.forEach((o) => {
      summary[o.status] = (summary[o.status] || 0) + 1;
      if (o.status === "completed") totalRevenue += o.totalPrice;
    });
    return { ...summary, totalRevenue };
  }
}

// 운영 예시
const stats = Order.summary();
console.log(`🔄 Pending: ${stats.pending}건`);
console.log(
  `✅ Completed: ${stats.completed}건 (매출 ${stats.totalRevenue}원)`
);
console.log(`❌ Failed: ${stats.failed}건`);

console.log(
  "⚙️ Pending IDs:",
  Order.getOrdersByStatus("pending").map((o) => o.id)
);
```

---

## 🌿 **OOP: 실무와 일상을 유기적으로 연결하는 언어**

**📢 이 설계는 ‘실무를 한 번 엿보는 간접 경험’입니다.**

- 🛠️ **지금은 연습일 뿐, 코드를 모두 외울 필요는 없습니다.**
- 🔍 중요한 건 “왜 이렇게 설계했을까?”, “이 구조가 어떤 문제를 해결할까?”를 끊임없이 고민하는 것입니다.
- 🌱 앞으로 Node.js, React 같은 새로운 기술을 배울 때도, 여기서 쌓은 **설계적 사고**가 여러분의 든든한 나침반이 될 것입니다.
- 🧠 문제를 만날 때마다 “이 원칙이 실무에선 어떻게 적용될까?”를 떠올리며, **작은 개선을 멈추지 마세요.**
- 🌐 OOP는 단순한 문법이 아니라, 복잡한 현실을 더 나은 방향으로 풀어내는 **삶의 설계 언어**입니다.
- 🚀 여러분의 코드 한 줄, 설계 하나가 누군가의 하루를 바꾸고, 더 나은 세상을 만드는 힘이 됩니다.
- 💪 **도전과 열정으로, 더 멋진 소프트웨어 여정을 이어가세요!**

---

**“코드는 세상을 설명하는 또 다른 언어이고,
설계는 더 나은 세상을 위한 우리의 약속입니다.”** ✨
